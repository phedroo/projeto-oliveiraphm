---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


```{r, include = FALSE}
### üåê Op√ß√µes globais para os chunks 

# "include = FALSE" 
  # C√≥digo vai ser executado, mas o c√≥digo e sa√≠da ocultam-se no documento final.
knitr::opts_chunk$set(
  collapse = TRUE, # sa√≠da e c√≥digo compilados no documento final
  message = FALSE, # ocultar mensagens geradas no documento final
  error = FALSE,   # ocultar mensagens de erro no documento final
  warning = FALSE, # ocultar mensagens de warning no documento final
  comment = "#>"   # define o prefixo usado nos resultados do c√≥digo
)
```

# MODELAGEM COMPUTACIONAL DA CONCENTRA√á√ÉO ATMOSF√âRICA DE CO~2~ e CH~4~ NO BRASIL CENTRAL

**Resumo**:  As mudan√ßas clim√°ticas globais s√£o uma preocupa√ß√£o mundial constante, sendo a principal causa o aumento da concentra√ß√£o de gases de efeito estufa (GEE) na atmosfera, especialmente o di√≥xido de carbono (CO~2~) e o metano (CH~4~). Para implementar medidas eficientes de mitiga√ß√£o das emiss√µes de GEE, √© fundamental compreender a din√¢mica desses gases na atmosfera e estabelecer rela√ß√µes com outras vari√°veis associadas ao sistema solo-planta-atmosfera. Nesse contexto, diversos esfor√ßos t√™m sido realizados para aprimorar as t√©cnicas de monitoramento de GEE em escala global e regional. Esta proposta tem como objetivo descrever a variabilidade espa√ßotemporal das concentra√ß√µes atmosf√©ricas de CO~2~ e CH~4~ em √°reas do Brasil Central, identificando fontes e poss√≠veis sumidouros desses gases ao longo dos anos de 2015 a 2023. Ser√£o adquiridos dados das concentra√ß√µes atmosf√©ricas de CO~2~ (X~CO2~) e CH~4~ (X~CH4~) a partir dos sensores orbitais GOSAT e OCO-2. Em adi√ß√£o, dados das vari√°veis clim√°ticas ser√£o obtidos na plataforma da Ag√™ncia Espacial Americana (NASA). Para todos os setores emissores de GEE, os dados ser√£o obtidos a partir dos relat√≥rios da plataforma Climate TRACE, coaliz√£o sem fins lucrativos capaz de rastrear e fornecer informa√ß√µes sobre as emiss√µes de GEE globalmente. A aquisi√ß√£o dos dados ser√° sistematizada para redu√ß√£o das diferen√ßas entre as resolu√ß√µes espaciais dos dados de sensoriamento remoto, com posterior remo√ß√£o da tend√™ncia mundial de X~CO2~ e X~CH4~. Para explora√ß√£o dos dados adquiridos, ser√£o utilizadas t√©cnicas explorat√≥rias multivariadas e an√°lise geoestat√≠stica, implementadas em linguagem R. A interrela√ß√£o entre as vari√°veis analisadas ser√° descrita por de reconhecimento de padr√£o, que inclu√≠ram an√°lises de agrupamento hier√°rquico e n√£o-hier√°rquico, an√°lise de componentes principais associadas aos padr√µes de variabilidade espacial. Espera-se que essa abordagem contribua para melhorar a compreens√£o da din√¢mica dos gases de efeito estufa na atmosfera e suas intera√ß√µes com vari√°veis clim√°ticas e de uso da terra no Brasil Central, auxiliando na formula√ß√£o de pol√≠ticas p√∫blicas voltadas para a mitiga√ß√£o das emiss√µes de GEE e, principalmente, a adapta√ß√£o √†s mudan√ßas clim√°ticas.

**Objetivo**: Analisar a variabilidade espa√ßotemporal das concentra√ß√µes atmosf√©ricas de CO~2~ e CH~4~ em √°reas do Brasil Central, identificando fontes e poss√≠veis sumidouros desses gases ao longo dos anos de 2015 a 2023, bem como suas rela√ß√µes com √≠ndices vegetativos e clim√°ticos, por meio de dados de GOSAT, OCO-2 e Climate TRACE.

## üë®‚Äçüî¨ Autores

-   **Pedro Henrique Marucio de Oliveira**\
    Graduando em Agronomia - FCAV/Unesp\
    Email: [pedro.marucio\@unesp.br](mailto:pedro.marucio@unesp.b)


-   **Prof. Dr. Alan Rodrigo Panosso**\
    Coorientador ‚Äî Departamento de Ci√™ncias Exatas - FCAV/Unesp\
    Email: [alan.panosso\@unesp.br](mailto:alan.panosso@unesp.br)

## üìÅ Etapas do Projeto

Os scripts abaixo foram desenvolvidos em RMarkdown e est√£o dispon√≠veis em formato HTML:

 - **Aquisi√ß√£o e download dos dados brutos** 
    -   [GOSAT](https://data.ceda.ac.uk/neodc/gosat/data/ch4/nceov1.0/CH4_GOS_OCPR/): Dados de concentra√ß√£o de CH~4~ 2009 a 2021\
    -   [OCO-2](https://disc.gsfc.nasa.gov): Dados de concentra√ß√£o de XCO~2~ (https://disc.gsfc.nasa.gov/datasets/OCO2_L2_Lite_FP_11.2r/summary?keywords=OCO2) e SIF (https://disc.gsfc.nasa.gov/datasets/OCO2_L2_Lite_SIF_11r/summary?keywords=OCO2\
    -   [Climate TRACE](https://climatetrace.org/): Dados de emiss√µes de GEE de 2015 a 2022\
    -   [AppEEARS](https://appeears.earthdatacloud.nasa.gov/task/point): Vari√°veis clim√°ticas e vegetativas\
    -   [nasapower](https://power.larc.nasa.gov/): Vari√°veis clim√°ticas (Temperatura; precipita√ß√£o; radia√ß√£o solar; umidade relativa; velocidade do vento e press√£o) de 2015 a 2024\
    -   [DETER](https://terrabrasilis.dpi.inpe.br/downloads/): Dados  de focos de fogo (cicatriz de queimadas)\
    -   [Desmatamento - INPE - PRODES - Plataforma   Terrabrasilis](https://terrabrasilis.dpi.inpe.br/geonetwork/srv/eng/catalog.search#/metadata/fe02f2bf-2cc0-49d5-ab72-a3954f997408): Dados sobre desmatamento de 31/07/2000 a 30/07/2023\
  
  - **Dados adicionais adquiridos (n√£o utilizados no trabalho)**
    -   [NASA](https://climate.nasa.gov/): Dados clim√°ticos\
    -   [NASA-FIRMS](https://firms.modaps.eosdis.nasa.gov): Dados de focos de inc√™ndio de 2015 a 2025\
    -   [BDQUEIMADAS](https://terrabrasilis.dpi.inpe.br/queimadas/bdqueimadas/#exportar-dados): Dados de focos de inc√™ndio de 2015 a 2025\
    -   [Programa Queimadas - INPE - Plataforma Terrabrasilis](https://terrabrasilis.dpi.inpe.br/queimadas/portal/): Dados de focos de queimadas x Supress√£o da vegeta√ß√£o nativa de 08/2018 a 01/2025 & Dados de focos de fogo ativo de 1998 a 21/01/2025\

## üßπ Faxina e Tratamento [script_geral](https://arpanosso.github.io//projeto-oliveiraphm//01_faxina_tratamento_dados.html) 

Nessa etapa foi realizada a faxina, filtragem e organiza√ß√£o inicial dos dados. Os dados de concentra√ß√£o atmosf√©rica de di√≥xido de carbono (XCO2) e metano (XCH4) foram devidamente processados e filtrados para o territ√≥rio brasileiro, incluindo:

Filtro geogr√°fico (apenas medi√ß√µes dentro do Brasil);  
Controle de qualidade (baseado nos flags de qualidade dos dados originais);  
Organiza√ß√£o por regi√µes (Norte, Nordeste, Sudeste, Sul e Centro-Oeste);  

### üîó Scripts de tratamentos e Links para Download dos dados processados:

| Script de Tratamento | Dados Processados Para Download
| :---: | :---:
| [nasa-xco2](https://arpanosso.github.io//projeto-oliveiraphm//nasa-xco2.html) | ‚¨áÔ∏è [nasa-xco2.rds](https://drive.google.com/file/d/1sVsLvBLxUB1YbqWyDUg177Eua2oREvgH/view?usp=sharing) 
| [gosat-xch4](https://arpanosso.github.io//projeto-oliveiraphm//gosat-xch4.html) | ‚¨áÔ∏è [gosat-xch4.rds](https://drive.google.com/file/d/1Rj-jcHOblEEb1ARMyJ1Jyfo4wCJnGliB/view?usp=drive_link)
| [oco2-sif](https://arpanosso.github.io//projeto-oliveiraphm//oco2-sif.html) | ‚¨áÔ∏è [oco2-sif.rds](https://drive.google.com/file/d/1c4WlEmgnwu7R_ENjzMTTg2a4mP1IaiG_/view?usp=sharing)
| [appeears-modis](https://arpanosso.github.io//projeto-oliveiraphm//appeears-modis.html) | ‚¨áÔ∏è [appeears-modis.rds](https://drive.google.com/file/d/15bpg2r2_XSWveyWrFu6oumt79UUlxzJr/view?usp=sharing)
| [emissions-sources](https://arpanosso.github.io//projeto-oliveiraphm//emissions-sources.html) | ‚¨áÔ∏è [emissions-sources.rds](https://drive.google.com/file/d/17erldRlIlTiB5sVtLWjsv4E--zZ3gmH-/view?usp=sharing)
| [nasa-power](https://arpanosso.github.io//projeto-oliveiraphm//nasa-xco2.html) | ‚¨áÔ∏è [nasa-power.rds](https://drive.google.com/file/d/13_PR3bQ9-ga_Wiv7jEv-GhYpAJwhmyTN/view?usp=sharing)
| [prodes-deforestation](https://arpanosso.github.io//projeto-oliveiraphm//prodes-deforestation.html) | ‚¨áÔ∏è [prodes-deforestation.rds](https://drive.google.com/file/d/1X4KJ_XK3GRcrwNCwWVEihJQBMGb72Z3S/view?usp=sharing)
| [deter-queimadas](https://arpanosso.github.io//projeto-oliveiraphm//deter-queimadas.html) | ‚¨áÔ∏è [deter-queimadas.rds](https://drive.google.com/file/d/1cmikkge6MtLJXuPBYeV-ZuMYoaNKP967/view?usp=sharing)
| [nasa-firms](https://arpanosso.github.io//projeto-oliveiraphm//nasa-firms.html) | ‚¨áÔ∏è [nasa-firms.rds](https://drive.google.com/file/d/1aMsbg35-QRBs-xiS8jl6lQ6feUySxM3e/view?usp=sharing)

Formato dos arquivos:

 > .rds (formato nativo do R para r√°pido carregamento)
 
 > salve os arquivos na pasta `data` do seu projeto

#### üõ†Ô∏è Pr√©-processameto [script](https://arpanosso.github.io//projeto-oliveiraphm//02_preprocessamento.html) 

#### ‚õìÔ∏è Incorpora√ß√£o das bases
[script](adicionar link)

### üõ† Prepara√ß√£o dos dados para an√°lise.
```{r}
library(tidyverse)
library(dplyr)
library(purrr) # criar fun√ß√µes
library(tibble)
library(corrplot)
library(vegan)
library(stringi)
source("R/my-function.R") 
```

#### Definindo estados
```{r}
my_states <- c("MS","MT","GO","DF")
```

## üí® Entrada com todas as bases atualizadas com os setores `base_completa_setores.rds`
```{r}
base_completa_setores <- read_rds('data/base_completa_setores.rds')
```

### Tratando outliers dos setores

Foram considerados outliers, pois n√£o foram encontradas bases j√° consolidadas (como o [SEEG](https://energiaeambiente.org.br/oito-dos-dez-municipios-que-mais-emitem-gases-de-efeito-estufa-estao-na-amazonia-20220617)) com tais valores de emiss√£o para os anos   

*Realizar a m√©dia das emiss√µes dos outliers com base nas observa√ß√µes da nova base*

Foram observados padr√µes de emiss√µes de acordo com os anos pares e √≠mpares, sendo assim, essa m√©dia ser√° passada para os anos pares e √≠mpares, separadamente, de 2015 a 2020, com o objetivo de manter este padr√£o

```{r}
# Fazendo m√©dia 
base_completa_set_novas_medias <- base_completa_setores |>
  filter(year %in% 2021:2024,
         city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos", "pocone")) |>
  # devemos caracterizar ano par e √≠mpar, para pare√°-los:
  mutate(paridade = if_else(year %% 2 == 0, "par", "impar")) |>
  # agrupar por paridade para que as m√©dias sejam feitas separadamente, por ano par e √≠mpar
  group_by(state, city_ref, paridade) |> 
  summarise(across(florestas_e_uso_da_terra:edificacoes, ~ mean(., na.rm = TRUE)), .groups = "drop")

# Atribuindo novos valores dos outliers de 2015 a 2020
base_completa_set_corrigida <- base_completa_setores |>
  mutate(paridade = if_else(year %% 2 == 0, "par", "impar")) |>
  left_join(base_completa_set_novas_medias, by = c("state", "city_ref", "paridade"), suffix = c("", "_media")) |>
  mutate(across(
    florestas_e_uso_da_terra:edificacoes,
    ~ ifelse(year < 2021 & city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos","pocone"),
             get(paste0(cur_column(), "_media")),
             .)
  )) |>
  select(-ends_with("_media"), -paridade)

# Verificar outliers
# base_completa_setores |>
#   pivot_longer(
#     cols = florestas_e_uso_da_terra:edificacoes,
#     names_to = "setor",
#     values_to = "emission"
#   ) |>
#   group_by(year, state, city_ref) |>
#   summarise(
#     emission = sum(emission/1e6, na.rm = TRUE)
#   ) |>
#   arrange(desc(emission)) |>
#   head(11)


# Verificar se a m√©dia foi corretamente passada
# base_completa_set_corrigida |> 
#   select(year:city_ref, agricultura:edificacoes) |> 
#   filter(year %in% 2015:2024,
#          city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos", "pocone"))
```

## üí® Entrada com todas as bases atualizadas com os subsetores `base_completa_subsetores.rds`

```{r}
base_completa_subsetores <- read_rds('data/base_completa_subsetores.rds')
```

### Tratando outliers dos subsetores... (ainda n√£o refeito para anos pares e √≠mpares)

Mesma l√≥gica que para os setores
```{r}
# Fazendo m√©dia 
base_completa_subset_novas_medias <- base_completa_subsetores |>
  filter(year %in% 2021:2024,
         city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos", "pocone")) |>
  # devemos caracterizar ano par e √≠mpar, para pare√°-los:
  mutate(paridade = if_else(year %% 2 == 0, "par", "impar")) |>
  # agrupar por paridade para que as m√©dias sejam feitas separadamente, por ano par e √≠mpar
  group_by(state, city_ref, paridade) |>
  summarise(across(degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais, ~ mean(., na.rm = TRUE)), .groups = "drop")

# Atribuindo novos valores dos outliers de 2015 a 2020
  base_completa_subset <- base_completa_subsetores |>
    # devemos caracterizar ano par e √≠mpar, para pare√°-los:
  mutate(paridade = if_else(year %% 2 == 0, "par", "impar")) |>
  # agrupar por paridade para que as m√©dias sejam feitas separadamente, por ano par e √≠mpar
    left_join(base_completa_subset_novas_medias, by = c("state", "city_ref", "paridade"), suffix = c("", "_media")) |>
    mutate(across(
      degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais,
      ~ ifelse(year < 2021 & city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos","pocone"),
               get(paste0(cur_column(), "_media")), # "cur_column()", "_media" Pega o valor da coluna de m√©dia correspondente
               .)
  )) |>
  select(-ends_with("_media"))

  
  # Verificar outliers
# base_completa_subsetores |>
#   select(year:city_ref,degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais) |>
#   filter(city_ref %in% c("sao jose do xingu", "sorriso", "taquaral de goias", "terenos", "pocone")) |>
#   pivot_longer(
#     cols = degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais,
#     names_to = "subsetor",
#     values_to = "emission"
#   ) |>
#   group_by(year, state, city_ref) |>
#   summarise(
#     emission = sum(emission/1e6, na.rm = TRUE)
#   ) |>
#   arrange(desc(emission)) |>
#   head(11)
```

# üîé An√°lises

<!--
### üßÆ Estat√≠stica descritiva

```{r,eval=FALSE}
# variavel <- "xco2" # opcional (mudar variavel)

# Criar vetor com as vari√°veis
variaveis <- base_completa_setores |>
  select(-year, -state, -city_ref) |>
  names()

# names(base_completa_setores) # ver colunas

# Fun√ß√£o de loop sobre as vari√°veis para facilitar processo
for (variavel in variaveis) {
  cat("Processando:", variavel, "\n")  # feedback

# df <- base_completa_setores |>
#   filter(state != 'DF') |> 
#   group_by(year,state) |>
#   summarise(
#     N = sum(!is.na(.data[[variavel]]), na.rm = TRUE), # observa√ß√µes
#     MIN = min(.data[[variavel]], na.rm = TRUE), # valor m√≠nimo
#     MEAN = mean(.data[[variavel]], na.rm = TRUE), # m√©dia
#     MEDIAN = median(.data[[variavel]], na.rm = TRUE), # mediana
#     MAX = max(.data[[variavel]], na.rm = TRUE), # valor m√°ximo
#     VARIANCIA  = var(.data[[variavel]], na.rm = TRUE),
#     STD_DV = sd(.data[[variavel]], na.rm = TRUE), # desvio padr√£o
#     CV = 100*STD_DV/MEAN, # coeficiete de varia√ß√£o
#     SKW = agricolae::skewness(.data[[variavel]]), #
#     KRT = agricolae::kurtosis(.data[[variavel]]), #
#   )

# Salvar
# writexl::write_xlsx(df, paste0("output/estat-descritiva-",variavel,"_.xlsx"))

}

```

### üìä Histogramas

```{r,eval=FALSE}
variavel <- "xco2" # mudar

# base resumida
base_completa_setores |>
  ggplot(aes(x=.data[[variavel]])) +
  geom_histogram(color="black",fill="gray",
                 bins = 30) +
  facet_wrap(~year, scales = "free") +
  theme_bw()
```

```{r,eval=FALSE}
base_completa |>
  mutate(
  fct_year = fct_rev(as.factor(year)),
  ) |>
  ggplot(aes(y=fct_year)) +
  ggridges::geom_density_ridges(rel_min_height = 0.03,
                      aes(x=.data[[variavel]], fill=state),
                      alpha = .6, color = "black"
  ) +
  scale_fill_viridis_d() +
  ggridges::theme_ridges() +
  theme(
    legend.position = "top"
  ) +
  labs(fill="")
```
-->

### üîÑ Atualiza√ß√£o da Base - C√°culo da Anomalia

```{r}
base_completa_set <- base_completa_set_corrigida |> 
  group_by(year) |> 
  mutate(anomalia_xco2 = xco2 - median(xco2,na.rm=TRUE),
         anomalia_xch4 = xch4 - median(xch4, na.rm=TRUE)) |> 
  dplyr::ungroup() |> 
  relocate(year:city_ref, xco2, anomalia_xco2, xch4, anomalia_xch4, sif_757, temperatura, umidade, precipitacao, pressao, radiacao, vento,media_fpar:media_ndvi, desmatamento,area_queimada) |> 
    select(-media_et) |> 
  rename(queimada = area_queimada, 
         fpar = media_fpar,
         lai = media_lai,
         evi = media_evi,
         ndvi = media_ndvi)
```


### üîé An√°lise de correla√ß√£o - entre setores

```{r,eval=FALSE}
mc_set <- cor(base_completa_set |>
            select(florestas_e_uso_da_terra:edificacoes, -operacoes_de_combustiveis_fosseis), use = "pairwise.complete.obs")
corrplot(mc_set,method = "color",
         outline = TRUE,
         type = "upper",
         addgrid.col = "darkgray",cl.pos = "r", tl.col = "black",
         tl.cex = .7, cl.cex = 1,  bg="azure2",
         # diag = FALSE,
         # addCoef.col = "black",
         cl.ratio = 0.2,
         cl.length = 5,
         number.cex = 0.8
) 
```

### üîé An√°lise de correla√ß√£o - total

```{r,eval=FALSE}
mc <- cor(base_completa_set |>
                select(anomalia_xco2:queimada, -xch4, -evi,-ndvi), use = "pairwise.complete.obs") # "complete.obs" descarta totalemnte linha com qualquer NA
corrplot(mc,method = "color",
         outline = TRUE,
         type = "upper",
         addgrid.col = "darkgray",cl.pos = "r", tl.col = "black",
         tl.cex = .8, cl.cex = 1,  bg="azure2",
         # diag = FALSE,
         # addCoef.col = "black",
         cl.ratio = 0.2,
         cl.length = 5,
         number.cex = 0.8
) 
```

### üîé An√°lise de correla√ß√£o - ANO 

```{r,eval=FALSE}
ngrp <- rep(3,9) # c(3,3,3,4,4,5,3,4, -) 
for( i in 2015:2023){
  # An√°lise de correla√ß√£o
  base_aux <- base_completa_set |>
    filter(year == i) |> 
    select(xco2:desmatamento, -evi, -ndvi,-xco2,-xch4, -temperatura,-sif_757) 
  
  municipios <-base_completa_set |>
    filter(year == i) |> 
    pull(city_ref)
  
  mc <- cor(base_aux,use = "pairwise.complete.obs")
  fc <- !is.na(mc[1,])
  fl <- !is.na(mc[,1])
  mc <- mc[fc,fl]
  mc <- mc[1:5,-(1:5)]
  corrplot(mc,method = "color",
           outline = TRUE,
           addgrid.col = "darkgray",cl.pos = "r", tl.col = "black",
           tl.cex = 1, cl.cex = 1,  bg="azure2",
           # diag = FALSE,
           addCoef.col = "black",
           cl.ratio = 0.2,
           cl.length = 5,
           number.cex = 0.8) 
  
  # An√°lise de agrupamento
  da_pad <- decostand(base_aux[,fc] |> 
                        mutate(across(everything(), ~replace_na(., 0))),  # inv√©s de passar NA = 0, n√£o podemos passar a mediana do estado?
                      method = "standardize",
                      na.rm=TRUE)
  da_pad_euc <- vegdist(da_pad,"euclidean") 
  da_pad_euc_ward<-hclust(da_pad_euc, method="ward.D")
  da_pad_euc_ward$labels <- municipios
  grupo<-cutree(da_pad_euc_ward,ngrp[i-2014]) #### numero de agrupamentos
  d <- da_pad_euc_ward$height
  d_corte <- d[which(d |> diff() == max(diff(d)))]
  plot(da_pad_euc_ward, 
       ylab="Dist√¢ncia Euclidiana",
       xlab="Acessos", hang=-1,
       col="blue", las=1,
       cex=.6,lwd=1.5);box();abline(h=d_corte*1.15)
  
  # Mapaeamento dos Grupos
  plot_map_group <- municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
        name_muni = names(grupo),
        grupo = as_factor(grupo)
      ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>      
    ggplot() +
    geom_sf(aes(fill=grupo), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Agrupamento',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_d()
  print(plot_map_group)
  
  pca <-  prcomp(da_pad,scale.=TRUE)
  # Autovalores
  eig<-pca$sdev^2
  print("==== Autovalores ====")
  print(round(eig,3))
  print("==== % da vari√¢ncia explicada ====")
  ve<-eig/sum(eig)
  print(round(ve,4))
  print("==== % da vari√¢ncia explicada acumulada ====")
  print(round(cumsum(ve),4)*100)
  print("==== Poder Discriminante ====")
  mcor<-cor(da_pad,pca$x)
  corrplot(mcor)
  
  pc1V<-cor(da_pad,pca$x)[,1]/sd(cor(da_pad,pca$x)[,1])
  pc2V<-cor(da_pad,pca$x)[,2]/sd(cor(da_pad,pca$x)[,2])
  pc3V<-cor(da_pad,pca$x)[,3]/sd(cor(da_pad,pca$x)[,3])
  pc1c<-pca$x[,1]/sd(pca$x[,1])
  pc2c<-pca$x[,2]/sd(pca$x[,2])
  pc3c<-pca$x[,3]/sd(pca$x[,3])
  nv<-ncol(mcor) # n√∫mero de vari√°veis utilizadas na an√°lise
      
  # gr√°fico biplot
  bip<-data.frame(pc1c,pc2c,pc3c,grupo)
  texto <- data.frame(
    x = pc1V,
    y = pc2V,
    z = pc3V,
    label = rownames(mcor)
  )
  for(k in 1:ngrp[i-2014]){
    cat(paste0("[Grupo ",k,"]:\n"), paste(municipios[grupo==k],collapse = "; "))
    cat("\n\n")
  }
  
  bi_plot <- bip |> 
    ggplot(aes(x=pc1c,y=pc2c,colour = as_factor(grupo))) +
    geom_point(size = 3) +
    theme_minimal() +
    # scale_shape_manual(values=16:18)+
    # scale_color_manual(values=c("#009E73", "#D55E00")) + #"#999999",
    # annotate(geom="text", x=pc1c, y=pc2c, label=cultivar,
    #             color="black",size=.25)+
    geom_vline(aes(xintercept=0),
               color="black", size=1)+
    geom_hline(aes(yintercept=0),
               color="black", size=1)+
    annotate(geom="segment",
             x=rep(0,nv),
             xend=texto$x,
             y=rep(0,nv),
             yend=texto$y,color="black",lwd=.5)+
    geom_label(data=texto,aes(x=x,y=y,label=label),
               color="black",angle=0,fontface="bold",size=3,fill="white")+
    labs(x=paste("CP1 (",round(100*ve[1],2),"%)",sep=""),
         y=paste("CP2 (",round(100*ve[2],2),"%)",sep=""),
         color="",shape="")+
    theme(legend.position = "top")+
    scale_color_viridis_d() #+
    # xlim(min(pc1c)*1.5,max(pc1c)*1.5) 
  print(bi_plot)
  
  print("==== Tabela da correla√ß√£o dos atributos com cada PC ====")
      ck<-sum(pca$sdev^2>=0.98)
      tabelapca<-vector()
      for( l in 1:ck) tabelapca<-cbind(tabelapca,mcor[,l])
      colnames(tabelapca)<-paste(rep(c("PC"),ck),1:ck,sep="")
      pcat<-round(tabelapca,3)
      tabelapca<-tabelapca[order(abs(tabelapca[,1])),]
      print(tabelapca)
}
```

## üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - setores

```{r}
# Remover outliers (trecho comentado pois os outliers agora foram tratados)
# Criando vetor com os municipios que s√£o outliers, nos anos em que s√£o outliers
  # observa√ß√£o: √© poss√≠vel fazer um replace dos valores para estes outliers com a m√©dia dos anos seguintes (2021 a 2025)

# remov_out <- base_completa_set |> filter(
#   state %in% my_states) |>
#   # select(-florestas_e_uso_da_terra) |> 
#   pivot_longer(
#     cols = florestas_e_uso_da_terra:edificacoes,
#     names_to = "setor",
#     values_to = "emission"
#   ) |> 
#   group_by(year, state, city_ref) |> 
#   summarise(
#     emission = sum(emission/1e6, na.rm = TRUE)
#   ) |> 
#   arrange(desc(emission)) |> 
#   head(11) |> 
#   pull(city_ref, year)

# Criando vetor para extrair os municipios de todos os tipos de emiss√µes, possibilitando a padroniza√ß√£o dos nomes para evitar outliers aparecendo
municipios <- base_completa_set |>
  mutate(
    city_ref = stri_trans_general(tolower(city_ref), "Latin-ASCII"),
    city_ref = trimws(city_ref)) |>
  pull(city_ref) |> unique()

padrao_municipios <- paste0(municipios, collapse = "|") 

# Gerando mapa
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
      base_completa_set |> 
        #remover edificacoes por estar presente s√≥ na nova base
        select(-edificacoes) |>
        mutate(florestas_e_uso_da_terra = ifelse(florestas_e_uso_da_terra>=0, florestas_e_uso_da_terra,0)) |> 
        filter(year == .x) |> 
        pivot_longer(
          cols = florestas_e_uso_da_terra:extracao_mineral, # n√£o considera edificacoes porque s√≥ tem na base 2021 a 2025, e devido remo√ß√µes, o de florestas 
          names_to = "setor",
          values_to = "emission"
        ) |> 
        group_by(year, state, city_ref) |> 
        summarise(
          emission = sum(emission, na.rm = TRUE)
        ) |> 
        select(state:emission) |> 
        rename(name_muni = city_ref)
       ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>
    ggplot() +
    geom_sf(aes(fill=emission/1e6), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Agrupamento',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_c()})
```



#### üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - setores - Criando classe de emiss√£o

```{r} 
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
        base_completa_set |> 
          #remover edificacoes por estar presente s√≥ na nova base
          select(-edificacoes) |>
          mutate(florestas_e_uso_da_terra = ifelse(florestas_e_uso_da_terra>0, florestas_e_uso_da_terra,0)) |> 
          filter(year == .x)|> 
          pivot_longer(
            cols = florestas_e_uso_da_terra:extracao_mineral, #remove edificacoes porque s√≥ tem na base 2021 a 2023 
            names_to = "setor",
            values_to = "emission"
          ) |> 
          group_by(year, state, city_ref) |> 
          summarise(
            emission = sum(emission, na.rm = TRUE)
          ) |> 
          select(state:emission) |> 
          rename(name_muni = city_ref)
      ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>  
    mutate(
      classe_emissao = case_when(
        emission <1e6 ~ ' <  1 Mton',
        emission <2e6 ~ ' <  2 Mton',
        emission >=2e6 ~ '>= 2 Mton'
      )
    ) |> 
    ggplot() +
    geom_sf(aes(fill=classe_emissao), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    labs(fill = 'Classe de emiss√£o',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_d()})
```
#### üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - escolher setor

```{r} 
setor = "agricultura" #mudar
# setor = c("agricultura", "florestas_e_uso_da_terra") #escolher mais de 1 setor...

# Gerando mapa
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
      base_completa_set |> 
        filter(year == .x) |> 
        pivot_longer(
          cols = setor, 
          names_to = "setor",
          values_to = "emission"
        ) |> 
        group_by(year, state, city_ref) |> 
        summarise(
          emission = sum(emission, na.rm = TRUE)
        ) |> 
        select(state:emission) |> 
        rename(name_muni = city_ref)
       ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>  
    mutate(
       classe_emissao = case_when(
       emission <1e6 ~ ' <  1 Mton',
       emission <2e6 ~ ' <  2 Mton',
       emission >=2e6 ~ '>= 2 Mton'
     )
    ) |> 
    ggplot() +
    geom_sf(aes(fill=classe_emissao), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    labs(fill = 'Agrupamento',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_d()})
```

## üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - subsetores

Aparentemente, muitos subsetores (n√£o consegui ver todos que s√£o) est√£o com suas metodologias alteradas, e isso esta gerando grande diverg√™ncia entre os mapas

```{r}
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
      base_completa_subset |> 
        mutate(
          # Valores n√£o positivos para essas colunas de remo√ß√£o recebem 0
            # Isso pois alguns subsetores cont√©m remo√ß√µes e emiss√µes juntas
    uso_liquido_de_terras_florestais = ifelse(uso_liquido_de_terras_florestais > 0, uso_liquido_de_terras_florestais, 0),
    uso_liquido_de_areas_arbustivas_e_gramineas = ifelse(uso_liquido_de_areas_arbustivas_e_gramineas > 0, uso_liquido_de_areas_arbustivas_e_gramineas, 0),
    uso_liquido_de_areas_umidas = ifelse(uso_liquido_de_areas_umidas > 0, uso_liquido_de_areas_umidas, 0)
  ) |>
    # Removendo subsetores que cont√©m remo√ß√µes
        # select(-remocoes_de_carbono_sequestro,
        #        -uso_liquido_de_terras_florestais, -uso_liquido_de_areas_arbustivas_e_gramineas, -uso_liquido_de_areas_umidas) |>
        filter(year == .x) |> 
        pivot_longer(
          cols = degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais,
          names_to = "subsetor",
          values_to = "emission"
        ) |> 
        group_by(year, state, city_ref) |> 
        summarise(
          emission = sum(emission, na.rm = TRUE)
        ) |> 
        select(state:emission) |> 
        rename(name_muni = city_ref)
       ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>      
    ggplot() +
    geom_sf(aes(fill=emission/1e6), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Agrupamento',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_c()})
```

#### üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - subsetores - Criando classe de emiss√£o

*Leves diferen√ßas do mapa de classes da emiss√£o total dos setores*

```{r} 
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
      base_completa_subset |> 
        mutate(
          # Valores n√£o positivos para essas colunas de remo√ß√£o recebem 0
            # Isso pois alguns subsetores cont√©m remo√ß√µes e emiss√µes juntas
    uso_liquido_de_terras_florestais = ifelse(uso_liquido_de_terras_florestais > 0, uso_liquido_de_terras_florestais, 0),
    uso_liquido_de_areas_arbustivas_e_gramineas = ifelse(uso_liquido_de_areas_arbustivas_e_gramineas > 0, uso_liquido_de_areas_arbustivas_e_gramineas, 0),
    uso_liquido_de_areas_umidas = ifelse(uso_liquido_de_areas_umidas > 0, uso_liquido_de_areas_umidas, 0)
  ) |>
    # Removendo subsetores que cont√©m remo√ß√µes
        # select(-remocoes_de_carbono_sequestro,
        #        -uso_liquido_de_terras_florestais, -uso_liquido_de_areas_arbustivas_e_gramineas, -uso_liquido_de_areas_umidas) |>
        filter(year == .x) |> 
        pivot_longer(
          cols = degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais,
          names_to = "setor",
          values_to = "emission"
        ) |> 
        group_by(year, state, city_ref) |> 
        summarise(
          emission = sum(emission, na.rm = TRUE)
        ) |> 
        select(state:emission) |> 
        rename(name_muni = city_ref)
       ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>  
    mutate(
       classe_emissao = case_when(
       emission <1e6 ~ ' <  1 Mton',
       emission <2e6 ~ ' <  2 Mton',
       emission >=2e6 ~ '>= 2 Mton'
     )
    ) |> 
    ggplot() +
    geom_sf(aes(fill=classe_emissao), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    labs(fill = 'Classe de emiss√£o',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_d()})
```


#### üó∫Ô∏è Mapa de EMISS√ÉO TOTAL - escolher subsetor

```{r} 
subsetor = "queimadas_em_areas_agricolas" #mudar
#detalhe: alguns subsetores como "degradacao_em_terras_florestais" s√≥ est√£o em uma das bases (nesse caso, na antiga)

# Escolher mais de 1 subsetor...
# subsetor = c("degradacao_em_terras_florestais", "queimadas_em_areas_agricolas", "fermentacao_enterica_gado_a_pasto", "desmatamento_em_terras_florestais", "queimadas_em_terras_florestais", "esterco_deixado_no_pasto_gado", "queimadas_em_areas_arbustivas", "queimadas_em_areas_umidas")
#detalhe: n√£o passar√° na legenda do mapa


# Gerando mapa
map(2015:2023,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
      base_completa_subset |> 
        filter(year == .x) |> 
        pivot_longer(
          cols = subsetor, 
          names_to = "subsetor",
          values_to = "emission"
        ) |> 
        group_by(year, state, city_ref) |> 
        summarise(
          emission = sum(emission, na.rm = TRUE)
        ) |> 
        select(state:emission) |> 
        rename(name_muni = city_ref)
       ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>
    mutate(
      classes_de_emissao = case_when(
        emission < 0.1e6 ~ "<0.1",
        emission < 0.4e6 ~ "<0.4",
        emission < 0.7e6 ~ "<0.7", 
        emission < 1e6 ~ "<1.0",
        emission >= 1e6 ~ ">=1.0"
      )
    ) |> 
    ggplot() +
    geom_sf(aes(fill=ifelse(emission > 2e6, emission/1e6, classes_de_emissao)), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    labs(fill = paste(subsetor, "(Mton)"),
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_d()})
```

## üó∫Ô∏è SETOR/SUBSETOR DE MAIOR EMISS√ÉO DA CIDADE

```{r}
# Unindo as bases climate TRACE
  # Feito caso queira visualizar os setores e subsetores de maior emiss√£o em um mesmo mapa
# base_completa_ct <- base_completa_set |> 
#   select(year:city_ref, florestas_e_uso_da_terra:edificacoes) |> 
#   full_join(base_completa_subset |> 
#               select(year:city_ref, degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais),
#             by = c("year", "city_ref", "state"))
```

## üó∫Ô∏è SETOR DE MAIOR EMISS√ÉO

```{r}
# Padronizar cores, criando vetor
padr_cor <- base_completa_set |> 
  select(florestas_e_uso_da_terra:edificacoes) |> 
  names()

# Paleta fixa 
cores_fixas <- viridis::viridis(length(padr_cor), option = "D")

map(2015:2024,~{municipality |> 
  mutate(
    name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
    name_muni = trimws(name_muni)
  )  |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    base_completa_set |> 
      select(year:city_ref, florestas_e_uso_da_terra:edificacoes) |> 
      mutate(florestas_e_uso_da_terra = ifelse(florestas_e_uso_da_terra>0,florestas_e_uso_da_terra,0)) |> 
      filter(year == .x) |> 
      pivot_longer(
        cols = florestas_e_uso_da_terra:edificacoes,
        names_to = "setores",
        values_to = "emission"
      ) |> 
      group_by(year, city_ref) |> 
      mutate(
        max_emission = max(emission,na.rm = TRUE),
        s_max_emission = ifelse(emission == max_emission,setores,NA)
      ) |> 
      filter(!is.na(s_max_emission)) |> 
      rename(name_muni = city_ref),
    by = "name_muni") |> 
  drop_na() |> 
  ggplot() +
    geom_sf(aes(fill=s_max_emission), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw()+
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Setor de Maior Emiss√£o',
         x = 'Longitude',
         y = 'Latitude') +
      scale_fill_manual(
        values = setNames(cores_fixas, padr_cor),
      )
  
  })
```
## üó∫Ô∏è SUBSETOR DE MAIOR EMISS√ÉO
```{r}
# Padronizar cores, criando vetor
padr_cor <- base_completa_subset |> 
  select(degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais) |> 
  names()

# Paleta fixa 
cores_fixas <- viridis::viridis(length(padr_cor), option = "D")

map(2015:2024,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      base_completa_subset |> 
        select(year:city_ref, degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais, -remocoes_de_carbono_sequestro) |>
        mutate(
          uso_liquido_de_terras_florestais = ifelse(uso_liquido_de_terras_florestais > 0, uso_liquido_de_terras_florestais, 0),
          uso_liquido_de_areas_arbustivas_e_gramineas = ifelse(uso_liquido_de_areas_arbustivas_e_gramineas > 0, uso_liquido_de_areas_arbustivas_e_gramineas, 0),
          uso_liquido_de_areas_umidas = ifelse(uso_liquido_de_areas_umidas > 0, uso_liquido_de_areas_umidas, 0)
        ) |> 
        filter(year == .x) |> 
        pivot_longer(
          cols = degradacao_em_terras_florestais:tratamento_e_descarte_de_efluentes_industriais,
          names_to = "subsetores",
          values_to = "emission"
        ) |> 
        group_by(year, city_ref) |> 
        mutate(
          max_emission = max(emission,na.rm = TRUE),
          s_max_emission = ifelse(emission == max_emission,subsetores,NA)
        ) |> 
        filter(!is.na(s_max_emission)) |> 
        rename(name_muni = city_ref),
      by = "name_muni") |> 
    drop_na() |> 
    ggplot() +
    geom_sf(aes(fill=s_max_emission), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw()+
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Subsetor de Maior Emiss√£o',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_manual(
      values = setNames(cores_fixas, padr_cor),
    )
  
})
```

  
## üó∫ Mapa de REMO√á√ÉO

Vale ressaltar que a nova metodologia do climate TRACE subdivide o subsetor de *remocoes_de_carbono_sequestro* (as remo√ß√µes) em 3 novos subsetores: 

*uso_liquido_de_terras_florestais*
*uso_liquido_de_areas_arbustivas_e_gramineas*
*uso_liquido_de_areas_umidas*

```{r}
# Primeiramente, √© necess√°rio passar os valores da coluna "remocoes_de_carbono_sequestro" da nova base do climate TRACE para negativos, para tornar a an√°lise visual entre os mapas iguais:
    # Tornando todos os valores absolutos positivos
      # base_completa_subset |>
      #   mutate(remocoes_de_carbono_sequestro = -abs(remocoes_de_carbono_sequestro)) |>  select(year,city_ref,remocoes_de_carbono_sequestro,uso_liquido_de_terras_florestais,uso_liquido_de_areas_arbustivas_e_gramineas,uso_liquido_de_areas_umidas)


map(2015:2024,~{municipality |> 
    mutate(
      name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
      name_muni = trimws(name_muni)
    )  |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      data.frame(
        base_completa_subset |> 
          mutate(remocoes_de_carbono_sequestro = -abs(remocoes_de_carbono_sequestro)) |> #valores absolutos negativos 
          filter(year == .x,
                 remocoes_de_carbono_sequestro <=0,
                 uso_liquido_de_terras_florestais<=0,
                 uso_liquido_de_areas_arbustivas_e_gramineas<=0,
                 uso_liquido_de_areas_umidas<=0) |> 
          pivot_longer(
            cols = c(remocoes_de_carbono_sequestro,uso_liquido_de_terras_florestais,uso_liquido_de_areas_arbustivas_e_gramineas,uso_liquido_de_areas_umidas),
            names_to = "subsector",
            values_to = "emission"
          ) |> 
          group_by(year, state, city_ref) |> 
          summarise(
            emission = sum(emission, na.rm = TRUE)
          ) |> 
          select(state:emission) |> 
          rename(name_muni = city_ref)
      ),by = "name_muni", relationship = "many-to-many"
    ) |> drop_na() |>      
    ggplot() +
    geom_sf(aes(fill=emission/1e6), color="transparent",
            size=.05, show.legend = TRUE)  +
    geom_sf(data=municipality |> filter(abbrev_state %in% my_states), fill="transparent", size=3, show.legend = FALSE) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Agrupamento',
         x = 'Longitude',
         y = 'Latitude') +
    scale_fill_viridis_c()})
```


## Instru√ß√µes - feitas ‚úÖ

1- Na incorpora√ß√£o retirar os subsetores (para n√£o contar duas vezes)
2- fazer a soma de emiss√£o por setor
3- pivto_wider com as emiss√£o para os diferentes setores nas colunas

## üìä VISUALIZANDO MAIORES EMISSORES PARA O SETOR DE AGRICULTURA OU P/ ANIMAL

```{r}
# Base antiga
emissions_sources_15_20 <- read_rds("data/emissions_sources.rds")

emissions_sources_15_20 |>
  filter(
    year == 2020,                   #%in% 2015:2022
    sigla_uf %in% my_states, # <-----
    str_detect(activity_units, 'animal'),
    # sector_name == 'agriculture',
    !source_name %in% city_ref,
    gas == 'co2e_100yr'
    ) |>
  group_by(city_ref, sigla_uf, sub_sector) |>
  summarise(
    emission = sum(emissions_quantity, na.rm = T)
  ) |>
  group_by(city_ref,sigla_uf) |>
  mutate(
    emission_total = sum(emission, na.rm = T)
  ) |>
  ungroup() |>
  group_by(sigla_uf) |>
  mutate(
    sigla_uf = ifelse(sigla_uf == "DF", "GO", sigla_uf)) |> 
  mutate(
    city_ref = city_ref |> fct_reorder(emission_total) |>
      fct_lump(n = 3, w = emission_total)) |>
  filter(city_ref != "Other") |>
  mutate(
      sub_sector = case_when(
        sub_sector == "enteric-fermentation-cattle-feedlot" ~ "FEGC",
        sub_sector == "enteric-fermentation-cattle-pasture" ~ "FEGP",
        sub_sector == "manure-left-on-pasture-cattle"  ~ "EP",
        sub_sector == "manure-management-cattle-feedlot" ~ "GEC",
        sub_sector == 'cropland-fires' ~ 'CF',
        sub_sector == 'synthetic-fertilizer-application' ~ 'SF application'
      )) |>
  ggplot(aes(emission/1e6, #passar de ton para Mton
             city_ref,
             fill = sub_sector)) +
  geom_col(col="black", lwd = 0.1) +
  xlab(bquote(Emissi√£o~CO[2]~e~(Mton))) +
  labs(#x = 'Emission (Mton)',
       y = 'Cidade',
       fill = 'Subsetor') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(1)),
    # axis.title.x = element_text(size = rel(2)),
    axis.text.y = element_text(size = rel(1.3)),
    # axis.title.y = element_text(size = rel(2)),
    legend.text = element_text(size = rel(1)),
    #legend.title = element_text(size = rel(1.7)),
    title = element_text(face = 'bold'),
    legend.position = 'top',
    legend.background = element_rect(fill = "transparent", color = "black")) +
      scale_fill_viridis_d(option ='plasma') +
  facet_wrap(~sigla_uf,scales = "free",ncol = 2) +
  annotate("text",
           x=2,
           y=1,
           label = ".",
           size=0.1)
```

## üìä VISUALIZANDO MAIORES EMISSORES PARA O SETOR DE AGRICULTURA OU P/ SEUS SUBSETORES

Base NOVA

Pegando a base antes da incorpora√ß√£o, apenas para reprensetar um ano de emiss√µes 

```{r}
# Base nova
# emissions_sources_21_24 <- readxl::read_excel("data-raw/climate-trace-br.xlsx")
# 
# emissions_sources_21_24 |> 
#   rename(city_ref = fonte,
#          emissao = emissao_co2e,
#          state = estado,
#          year = ano) |>
#   filter(
#     year == 2024,                   #%in% 2021:2024
#     state %in% my_states # <-----
#     # setor == Agricultura
#     ) |>
#   mutate(
#     subsetor_agricultura = ifelse(setor == "Agricultura", subsetor, NA),
#     city_ref = stri_trans_general(tolower(city_ref), "Latin-ASCII"),
#     city_ref = trimws(city_ref),
#     city_ref = str_extract(city_ref, padrao_municipios)
#   ) |> 
#   drop_na() |> 
#   select(year, state, city_ref, setor, subsetor_agricultura, emissao) |> 
#   group_by(state, city_ref, year,subsetor_agricultura) |>
#   summarise(
#     emissao_tot = sum(emissao, na.rm = T)
#   ) |>
#   ungroup() |>
#   group_by(state) |>
#   mutate(
#     city_ref = city_ref |> fct_reorder(emissao_tot) |>
#       fct_lump(n = 3, w = emissao_tot)) |>
#   filter(city_ref != "Other") |>
#   ggplot(aes(emissao_tot/1e6, #passar de ton para Mton
#              city_ref,
#              fill = subsetor_agricultura)) +
#   geom_col(col="black", lwd = 0.1) +
#   xlab(bquote(Emissi√£o~CO[2]~e~(Mton))) +
#   labs(#x = 'Emission (Mton)',
#        y = 'Cidade',
#        fill = 'Subsetor') +
#   theme_bw() +
#   theme(
#     axis.text.x = element_text(size = rel(1)),
#     # axis.title.x = element_text(size = rel(2)),
#     axis.text.y = element_text(size = rel(1.3)),
#     # axis.title.y = element_text(size = rel(2)),
#     legend.text = element_text(size = rel(1)),
#     #legend.title = element_text(size = rel(1.7)),
#     title = element_text(face = 'bold'),
#     legend.position = 'top',
#     legend.background = element_rect(fill = "transparent", color = "black")) +
#       scale_fill_viridis_d(option ='plasma') +
#   facet_wrap(~state,scales = "free",ncol = 2) +
#   annotate("text",
#            x=2,
#            y=1,
#            label = ".",
#            size=0.1) |> 
#   mutate(
#       sub_sector = case_when(
#         subsetor_agricultura == "esterco aplicado ao solo" ~ "EAS",
#         subsetor_agricultura == "" ~ "FEGP",
#         subsetor_agricultura == ""  ~ "EP",
#         subsetor_agricultura == "" ~ "GEC",
#         subsetor_agricultura == '' ~ 'CF',
#         subsetor_agricultura == '' ~ 'SF application'
#       ))

# 
#   ggplot(aes(emission/1e6, #passar de ton para Mton
#              city_ref,
#              fill = sub_sector)) +
#   geom_col(col="black", lwd = 0.1) +
#   xlab(bquote(Emissi√£o~CO[2]~e~(Mton))) +
#   labs(#x = 'Emission (Mton)',
#        y = 'Cidade',
#        fill = 'Subsetor') +
#   theme_bw() +
#   theme(
#     axis.text.x = element_text(size = rel(1)),
#     # axis.title.x = element_text(size = rel(2)),
#     axis.text.y = element_text(size = rel(1.3)),
#     # axis.title.y = element_text(size = rel(2)),
#     legend.text = element_text(size = rel(1)),
#     #legend.title = element_text(size = rel(1.7)),
#     title = element_text(face = 'bold'),
#     legend.position = 'top',
#     legend.background = element_rect(fill = "transparent", color = "black")) +
#       scale_fill_viridis_d(option ='plasma') +
#   facet_wrap(~sigla_uf,scales = "free",ncol = 2) +
#   annotate("text",
#            x=2,
#            y=1,
#            label = ".",
#            size=0.1)
```















