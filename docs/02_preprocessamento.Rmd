---
title: "Pr√©-Processamento"
author: "Oliveria, PHM; Panosso, AR"
date: "2025-10-02"
output: html_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, # sa√≠da e c√≥digo compilados no documento final
  message = FALSE, # ocultar mensagens geradas no documento final
  error = FALSE,   # ocultar mensagens de erro no documento final
  warning = FALSE, # ocultar mensagens de warning no documento final
  eval = FALSE,
  comment = "#>"   # define o prefixo usado nos resultados do c√≥digo
)
```

### üõ†Ô∏è Pr√©-processameto [script](https://arpanosso.github.io//projeto-oliveiraphm//02_preprocessamento.html) 

### üõ† Prepara√ß√£o dos dados para an√°lise.
```{r}
library(tidyverse)
library(ggridges)
library(ggpubr)
library(geobr)
library(gstat)
library(vegan)
library(sf)
library(dplyr)
library(lwgeom) # para st_make_valid
source("../R/my-function.R")
```
#### Definindo estados
```{r, eval=FALSE}
my_states <- c("MS","MT","GO","DF")
```

### üí® Entrada com a Base: `emissions-sources.rds`
```{r, eval=FALSE}
emissions_sources <- read_rds("data/emissions-sources.rds")|> 
  filter(sigla_uf %in% my_states)
glimpse(emissions_sources)
```


### üí® Entrada com a Base: `nasa-xco2.rds`
```{r, eval=FALSE}
nasa_xco2 <- read_rds("../data/nasa-xco2.rds") |> 
  filter(state %in% my_states)
glimpse(nasa_xco2)
```

#### Filtrando os pol√≠gonos do munic√≠pios
```{r, eval=FALSE}
munici_state <- municipality |> 
  filter(abbrev_state %in% my_states)
pol_ms <- states |> filter(abbrev_state == "MS") |> 
  pull(geom) |> pluck(1) |> as.matrix()
pol_mt <- states |> filter(abbrev_state == "MT") |> 
  pull(geom) |> pluck(1) |> as.matrix()
pol_go <- states |> filter(abbrev_state == "GO") |> 
  pull(geom) |> pluck(1) |> as.matrix()
pol_df <- states |> filter(abbrev_state == "DF") |> 
  pull(geom) |> pluck(1) |> as.matrix()
```


#### Classificando cada ponto em munic√≠pio
```{r, eval=FALSE}
# resul <- vector()
# estado <- nasa_xco2$state
# for(i in 1:nrow(nasa_xco2)){
#   if(estado[i]!="Other"){
#     my_citys_obj <- municipality %>%
#       filter(abbrev_state == estado[i])
#     n_citys <- nrow(my_citys_obj)
#     my_citys_names <- my_citys_obj %>% pull(name_muni)
#     resul[i] <- "Other"
#     for(j in 1:n_citys){
#       pol_city <- my_citys_obj$geom  %>%
#         purrr::pluck(j) %>%
#         as.matrix()
#       if(def_pol(nasa_xco2$longitude[i],
#                  nasa_xco2$latitude[i],
#                  pol_city)){
#         resul[i] <- my_citys_names[j]
#       }
#     }
#   }
# }
# nasa_xco2$city_ref <- resul
# write_rds(nasa_xco2,"data/nasa-xco2.rds")
```

#### Gerar mapa
```{r, eval=FALSE}
my_year = 2015
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    nasa_xco2 |> 
      group_by(year, city_ref) |> 
      filter(year == my_year) |> 
      summarise(
        xco2 = mean(xco2,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(  name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  ggplot()  +
  geom_sf(aes(fill=xco2), color="transparent",
          size=.05, show.legend = TRUE)  +
  geom_point(data = nasa_xco2 |> 
               filter(year==my_year), 
               aes(longitude, latitude, #size = emission,
                   color="red"))+
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'xco2',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```


#### Criando o grid (malha de pontos) para valores n√£o amostrados - nasa-xco2
```{r, eval=FALSE}
# vetores para coordenadas x e y selecionadas da base do IBGE1
# Extrair coordenadas da base nasa_xco2 para definir extens√£o do grid
x<-nasa_xco2$longitude
y<-nasa_xco2$latitude
dis <- 0.5 # dist√¢ncia (do grid) para adensamento de pontos nos estados
grid_geral <- expand.grid( # Criar malha regular
  X=seq(min(x),max(x),dis), # Combinar cada x e y
  Y=seq(min(y),max(y),dis)) |>
  mutate( #teste ponto-no-pol√≠gono, TRUE se (X,Y) caem no pol√≠gono
    flag_ms = def_pol(X, Y, pol_ms),
    flag_mt = def_pol(X, Y, pol_mt),
    flag_go = def_pol(X, Y, pol_go),
    flag_df = def_pol(X, Y, pol_df)
  ) |>
  filter(flag_ms | flag_go | flag_mt | flag_df) |> # manter pontos correspondentes ao menos 1 dos limites
  select(-c(flag_ms,flag_mt,flag_go,flag_df)) # remover colunas criadas
plot(grid_geral)
sp::gridded(grid_geral) = ~ X + Y
```

#### Interpola√ß√£o por Krigagem Ordin√°ria

  Estimar valores m√©dios de concentra√ß√£o de CO2 entre 2015 e 2023
```{r, eval=FALSE}
df_aux <- nasa_xco2 |> 
  filter(year == my_year) |> 
  group_by(longitude, latitude) |> 
  summarise(
    xco2 = mean(xco2,na.rm=TRUE), # m√©dia xco2
    .groups = "drop"
  ) |> sample_n(10000) 
sp::coordinates(df_aux) = ~ longitude + latitude # Converter data frame para objeto espacial - atribuir as colunas longitude/latitude como coordenadas. V√°rias fun√ß√µes de geoestat√≠stica do pacote gstat (como variogram() e krige()) n√£o aceitam um data.frame, mas um objeto com coordenadas. Agora, a vari√°vel xco2 passa a ser o atributo associado a cada ponto espacial.

form <- xco2 ~ 1 # "~ 1" modelo de m√©dia constante, mas desconhecida (somente intercepto - assume m√©dia global, sem covari√°veis).

vari_exp <- gstat::variogram(form, data = df_aux,
                      cressie = FALSE, #estimador cl√°ssico do semivar.
                      cutoff = 1, # dist√¢ncia m√°xima = 8
                      width = 0.075) # distancia entre pontos
vari_exp  |>
  ggplot(aes(x=dist, y=gamma)) +
  geom_point() +
  labs(x="lag (¬∫)",
       y=expression(paste(gamma,"(h)")))
```


```{r, eval=FALSE}
patamar=1.4
alcance=0.2
epepita=0.5
modelo_1 <- fit.variogram(vari_exp,vgm(patamar,"Sph",alcance,epepita))
modelo_2 <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
modelo_3 <- fit.variogram(vari_exp,vgm(patamar,"Gau",alcance,epepita))
plot_my_models(modelo_1,modelo_2,modelo_3)
modelo <- modelo_2 ## sempre modificar
```

```{r, eval=FALSE}
ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                     block=c(0.1,0.1),
                     nsim=0,
                     na.action=na.pass,
                     debug.level=-1
)
```


```{r, eval=FALSE}
ko_variavel |> 
  as_tibble() |> 
    ggplot(aes(x=X, y=Y)) +
  geom_tile(aes(fill = var1.pred)) +
  scale_fill_viridis_c(option = "mako") +
  coord_equal() +
  labs(x="Longitude",
       y="Latitude",
       fill="xco2",
       title = my_year) +
  theme_bw()
```

```{r, eval=FALSE}
df_kgr <- ko_variavel |> 
      as_tibble() |> 
      select(-var1.var) |> 
      rename(longitude=X,latitude=Y,xco2=var1.pred)  |> 
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF"))) 
             )
resul <- vector()
estado <- df_kgr$state
for(i in 1:nrow(df_kgr)){
  if(estado[i]!="Other"){
    my_citys_obj <- municipality %>%
      filter(abbrev_state == estado[i])
    n_citys <- nrow(my_citys_obj)
    my_citys_names <- my_citys_obj %>% pull(name_muni)
    resul[i] <- "Other"
    for(j in 1:n_citys){
      pol_city <- my_citys_obj$geom  %>%
        purrr::pluck(j) %>%
        as.matrix()
      if(def_pol(df_kgr$longitude[i],
                 df_kgr$latitude[i],
                 pol_city)){
        resul[i] <- my_citys_names[j]
      }
    }
  }
}
df_kgr$city_ref <- resul
```


```{r, eval=FALSE}
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    nasa_xco2 |> 
      filter(year == my_year) |> 
      select(longitude,latitude,xco2,state,city_ref) |> 
      rbind(
        df_kgr
      ) |> 
      group_by(city_ref) |> 
      summarise(
        xco2 = mean(xco2,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(  name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  mutate(
    xco2 = ifelse(is.na(xco2),median(xco2,na.rm = TRUE),xco2)) |>
  ggplot()  +
  geom_sf(aes(fill=xco2), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = df_kgr, 
  #            aes(longitude, latitude, #size = emission,
  #                color="red")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'xco2',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```

#### Estimativa de XCO2 para o Brasil Central

```{r, eval=FALSE}
nasa_xco2_kgr <- map_df(2015:2023,~{
  set.seed(1235)
  df_aux <- nasa_xco2 |>
    group_by(longitude, latitude) |>
    filter(year == .x) |>
    summarise(
      xco2 = mean(xco2,na.rm=TRUE),
      .groups = "drop"
    ) |> sample_n(8000)
  sp::coordinates(df_aux) = ~ longitude + latitude
  form <- xco2 ~ 1
  vari_exp <- gstat::variogram(form, data = df_aux,
                               cressie = FALSE,
                               cutoff = 1, # dist√¢ncia m√°xima 8
                               width = 0.075) # distancia entre pontos
  vari_exp  |>
    ggplot(aes(x=dist, y=gamma)) +
    geom_point() +
    labs(x="lag (¬∫)",
         y=expression(paste(gamma,"(h)")))
  patamar=1.4
  alcance=0.2
  epepita=0.5
  modelo <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
  ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                       block=c(0.1,0.1),
                       nsim=0,
                       na.action=na.pass,
                       debug.level=-1
  )
  df_kgr <- ko_variavel |>
      as_tibble() |>
      select(-var1.var) |>
      rename(longitude=X,latitude=Y,xco2=var1.pred)  |>
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF")))
             )
  resul <- vector()
  estado <- df_kgr$state
  for(i in 1:nrow(df_kgr)){
    if(estado[i]!="Other"){
      my_citys_obj <- municipality %>%
        filter(abbrev_state == estado[i])
      n_citys <- nrow(my_citys_obj)
      my_citys_names <- my_citys_obj %>% pull(name_muni)
      resul[i] <- "Other"
      for(j in 1:n_citys){
        pol_city <- my_citys_obj$geom  %>%
          purrr::pluck(j) %>%
          as.matrix()
        if(def_pol(df_kgr$longitude[i],
                   df_kgr$latitude[i],
                   pol_city)){
          resul[i] <- my_citys_names[j]
        }
      }
    }
  }
  df_kgr$city_ref <- resul

  df_final <- df_kgr |>
        mutate(year = .x)
  return(df_final)
})
# write_rds(nasa_xco2_kgr,"../data-raw/nasa-xco2-kgr.rds")
```

```{r, eval=FALSE}
nasa_xco2_kgr <- read_rds("../data-raw/nasa-xco2-kgr.rds")
```

```{r, eval=FALSE}
nasa_xco2_bind <- nasa_xco2 |> 
  select(longitude,latitude,xco2,city_ref,state,year) |> 
  rbind(nasa_xco2_kgr)

# Conferindo o munic√≠pios de GO que estavam faltando --> Agora est√£o certos (~230)
# nasa_xco2_bind |> 
#   filter(state == "GO") |> 
#   pull(city_ref) |> unique()

map(2015:2023,~{
  municipality |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      nasa_xco2_bind |> 
        filter(year == .x) |> 
        select(longitude,latitude,xco2,state,city_ref) |> 
        group_by(city_ref) |> 
        summarise(
          xco2 = mean(xco2,na.rm=TRUE),
          .groups = "drop"
        ) |> 
        rename(  name_muni = city_ref),
      by = c("name_muni")
    ) |> 
    mutate(
      xco2 = ifelse(is.na(xco2),median(xco2,na.rm = TRUE),xco2)) |>
    ggplot()  +
    geom_sf(aes(fill=xco2), color="transparent",
            size=.05, show.legend = TRUE)  +
    # geom_point(data = df_kgr, 
    #            aes(longitude, latitude, #size = emission,
    #                color="red")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'xco2',
         x = 'Longitude',
         y = 'Latitude',
         title = .x) +
    scale_fill_viridis_c()})

# Salvar arquivo interpolado
# write_rds(nasa_xco2_bind,"../data/nasa-xco2-bind.rds")
```


### üí® Entrada com a Base: `gosat-xch4.rds`
```{r, eval=FALSE}
gosat_xch4 <- read_rds("../data/gosat_xch4.rds") |> 
  filter(state %in% my_states) |> 
  select(-flag_nordeste, -flag_br)

glimpse(gosat_xch4)
```


```{r, eval=FALSE}
gosat_xch4 |> 
  filter(year == 2021) |> 
  ggplot(aes(x=longitude,y=latitude)) +
  geom_point()
```

#### Classificando cada ponto em munic√≠pio

J√° feito no arquivo da pasta docs

#### Gerar mapa
```{r, eval=FALSE}
gosat_xch4 <- read_rds("../data/gosat_xch4.rds") # os arquivos com underline foram tratados, classificados por munic√≠pio e dever√£o ser repassados para a pasta data futuramente

my_year = 2021
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    gosat_xch4 |> 
      group_by(year, city_ref) |> 
      summarise(
        xch4 = mean(xch4,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  filter(year == my_year) |> 
  ggplot()  +
  geom_sf(aes(fill=xch4), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = gosat_xch4 |> 
  #              filter(year==my_year), 
  #              aes(longitude, latitude, #size = emission,
  #                  color="red"))+
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'xch4',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()

# unidade partes por blih√£o (ppb)
```

#### Criando o grid (malha de pontos) para valores n√£o amostrados - gosat-xch4
```{r, eval=FALSE}
# vetores para coordenadas x e y selecionadas da base do IBGE1
# Extrair coordenadas da base gosat_xch4 para definir extens√£o do grid
x<-gosat_xch4$longitude
y<-gosat_xch4$latitude
dis <- 0.5 # dist√¢ncia (do grid) para adensamento de pontos nos estados
grid_geral <- expand.grid( # Criar malha regular
  X=seq(min(x),max(x),dis), # Combinar cada x e y
  Y=seq(min(y),max(y),dis)) |>
  mutate( #teste ponto-no-pol√≠gono, TRUE se (X,Y) caem no pol√≠gono
    flag_ms = def_pol(X, Y, pol_ms),
    flag_mt = def_pol(X, Y, pol_mt),
    flag_go = def_pol(X, Y, pol_go),
    flag_df = def_pol(X, Y, pol_df)
  ) |>
  filter(flag_ms | flag_go | flag_mt | flag_df) |> # manter pontos correspondentes ao menos 1 dos limites
  select(-c(flag_ms,flag_mt,flag_go,flag_df)) # remover colunas criadas
plot(grid_geral)
sp::gridded(grid_geral) = ~ X + Y
```

#### Interpola√ß√£o por Krigagem Ordin√°ria - gosat-xch4

  Estimar valores m√©dios de concentra√ß√£o de CH4 entre 2015 e 2021
```{r, eval=FALSE}
df_aux <- gosat_xch4 |> 
  filter(year == my_year) |> 
  group_by(longitude, latitude) |> 
  summarise(
    xch4 = mean(xch4,na.rm=TRUE), # m√©dia xch4
    .groups = "drop"
  ) 
sp::coordinates(df_aux) = ~ longitude + latitude # Converter data frame para objeto espacial - atribuir as colunas longitude/latitude como coordenadas. V√°rias fun√ß√µes de geoestat√≠stica do pacote gstat (como variogram() e krige()) n√£o aceitam um data frame, mas sim um objeto com coordenadas. Agora, a vari√°vel xch4 passa a ser o atributo associado a cada ponto espacial.

form <- xch4 ~ 1 # "~ 1" modelo de m√©dia constante, mas desconhecida (somente intercepto - assume m√©dia global, sem covari√°veis).

vari_exp <- gstat::variogram(form, data = df_aux,
                      cressie = FALSE, #estimador cl√°ssico do semivar.
                      cutoff = 32, # dist√¢ncia  
                      width = 2) # distancia entre pontos
vari_exp  |>
  ggplot(aes(x=dist, y=gamma)) +
  geom_point() +
  labs(x="lag (¬∫)",
       y=expression(paste(gamma,"(h)")))
```

```{r, eval=FALSE}
patamar=1250
alcance=33
epepita=197
modelo_1 <- fit.variogram(vari_exp,vgm(patamar,"Sph",alcance,epepita))
modelo_2 <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
modelo_3 <- fit.variogram(vari_exp,vgm(patamar,"Gau",alcance,epepita))
plot_my_models(modelo_1,modelo_2,modelo_3)
modelo <- modelo_2 ## sempre modificar
```

```{r, eval=FALSE}
ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                     block=c(0.1,0.1),
                     nsim=0,
                     na.action=na.pass,
                     debug.level=-1
)
```

```{r, eval=FALSE}
ko_variavel |> 
  as_tibble() |> 
    ggplot(aes(x=X, y=Y)) +
  geom_tile(aes(fill = var1.pred)) +
  scale_fill_viridis_c(option = "mako") +
  coord_equal() +
  labs(x="Longitude",
       y="Latitude",
       fill="xch4",
       title = my_year) +
  theme_bw()
```

```{r, eval=FALSE}
df_kgr <- ko_variavel |> 
      as_tibble() |> 
      select(-var1.var) |> 
      rename(longitude=X,latitude=Y,xch4=var1.pred)  |> 
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF"))) 
             )
resul <- vector()
estado <- df_kgr$state
for(i in 1:nrow(df_kgr)){
  if(estado[i]!="Other"){
    my_citys_obj <- municipality %>%
      filter(abbrev_state == estado[i])
    n_citys <- nrow(my_citys_obj)
    my_citys_names <- my_citys_obj %>% pull(name_muni)
    resul[i] <- "Other"
    for(j in 1:n_citys){
      pol_city <- my_citys_obj$geom  %>%
        purrr::pluck(j) %>%
        as.matrix()
      if(def_pol(df_kgr$longitude[i],
                 df_kgr$latitude[i],
                 pol_city)){
        resul[i] <- my_citys_names[j]
      }
    }
  }
}
df_kgr$city_ref <- resul
```


```{r, eval=FALSE}
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    gosat_xch4 |> 
      filter(year == my_year) |> 
      select(longitude,latitude,xch4,state,city_ref) |> 
      rbind(
        df_kgr
      ) |> 
      group_by(city_ref) |> 
      summarise(
        xch4 = mean(xch4,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(  name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  mutate(
    xch4 = ifelse(is.na(xch4),median(xch4,na.rm = TRUE),xch4)) |>
  ggplot()  +
  geom_sf(aes(fill=xch4), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = df_kgr, 
  #            aes(longitude, latitude, #size = emission,
  #                color="red")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'xch4',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```

#### Estimativa de XCH4 para o Brasil Central

```{r, eval=FALSE}
# Warning haviam sido removidos, mas voltaram aparecer - revisar modelos 
gosat_xch4_kgr <- map_df(2015:2021,~{
  set.seed(1235)
  df_aux <- gosat_xch4 |>
    group_by(longitude, latitude) |>
    filter(year == .x) |>
    summarise(
      xch4 = mean(xch4,na.rm=TRUE),
      .groups = "drop"
    ) |> sample_n(1961)
  sp::coordinates(df_aux) = ~ longitude + latitude
  form <- xch4 ~ 1
  vari_exp <- gstat::variogram(form, data = df_aux,
                               cressie = FALSE,
                               cutoff = 32, # dist√¢ncia m√°xima 
                               width = 2) # distancia entre pontos
  vari_exp  |>
    ggplot(aes(x=dist, y=gamma)) +
    geom_point() +
    labs(x="lag (¬∫)",
         y=expression(paste(gamma,"(h)")))
  patamar=1250
  alcance=33
  epepita=197
  modelo <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
  ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                       block=c(0.1,0.1),
                       nsim=0,
                       na.action=na.pass,
                       debug.level=-1
  )
  df_kgr <- ko_variavel |>
      as_tibble() |>
      select(-var1.var) |>
      rename(longitude=X,latitude=Y,xch4=var1.pred)  |>
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF")))
             )
  resul <- vector()
  estado <- df_kgr$state
  for(i in 1:nrow(df_kgr)){
    if(estado[i]!="Other"){
      my_citys_obj <- municipality %>%
        filter(abbrev_state == estado[i])
      n_citys <- nrow(my_citys_obj)
      my_citys_names <- my_citys_obj %>% pull(name_muni)
      resul[i] <- "Other"
      for(j in 1:n_citys){
        pol_city <- my_citys_obj$geom  %>%
          purrr::pluck(j) %>%
          as.matrix()
        if(def_pol(df_kgr$longitude[i],
                   df_kgr$latitude[i],
                   pol_city)){
          resul[i] <- my_citys_names[j]
        }
      }
    }
  }
  df_kgr$city_ref <- resul

  df_final <- df_kgr |>
        mutate(year = .x)
  return(df_final)
})
# write_rds(gosat_xch4_kgr,"data-raw/gosat-xch4-kgr.rds")
```

```{r, eval=FALSE}
xch4_kgr <- read_rds("../data-raw/gosat-xch4-kgr.rds")
```

```{r, eval=FALSE}
gosat_xch4_bind <- gosat_xch4 |> 
  select(longitude,latitude,xch4,city_ref,state,year) |> 
  rbind(gosat_xch4_kgr)

map(2015:2021,~{
  municipality |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      gosat_xch4_bind |> 
        filter(year == .x) |> 
        select(longitude,latitude,xch4,state,city_ref) |> 
        group_by(city_ref) |> 
        summarise(
          xch4 = mean(xch4,na.rm=TRUE),
          .groups = "drop"
        ) |> 
        rename(name_muni = city_ref),
      by = c("name_muni")
    ) |> 
    mutate(
      xch4 = ifelse(is.na(xch4),median(xch4,na.rm = TRUE),xch4)) |>
    ggplot()  +
    geom_sf(aes(fill=xch4), color="transparent",
            size=.05, show.legend = TRUE)  +
    # geom_point(data = df_kgr, 
    #            aes(longitude, latitude, #size = emission,
    #                color="red")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'xch4',
         x = 'Longitude',
         y = 'Latitude',
         title = .x) +
    scale_fill_viridis_c()})

# Salvar arquivo interpolado
# write_rds(gosat_xch4_bind,"../data/gosat_xch4_bind.rds")
```

### üçÉ Entrada com a Base: `oco2-sif.rds`
```{r, eval=FALSE} 
oco2_sif <- read_rds("../data/oco2-sif.rds") |> 
  rename(SIF_757 = daily_sif757)

glimpse(oco2_sif)
```

```{r, eval=FALSE}
oco2_sif |>
  filter(year == 2022,
         state %in% my_states) |>  # Brasil Central
  ggplot(aes(x=longitude,y=latitude)) +
  geom_point()
```


#### Gerar mapa
```{r, eval=FALSE}
my_year = 2022
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    oco2_sif |> 
      group_by(year, city_ref) |> 
      summarise(
        SIF_757 = mean(SIF_757,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  filter(year == my_year) |> 
  ggplot()  +
  geom_sf(aes(fill=SIF_757), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = oco2_sif |> 
  #              filter(year==my_year), 
  #              aes(longitude, latitude, #size = emission,
  #                  color="red"))+
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'SIF757',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```

#### Criando o grid (malha de pontos) para valores n√£o amostrados - oco2-sif
```{r, eval=FALSE}
# vetores para coordenadas x e y selecionadas da base do IBGE1
# Extrair coordenadas da base oco2_sif para definir extens√£o do grid
x<-oco2_sif$longitude
y<-oco2_sif$latitude
dis <- 0.5 # dist√¢ncia (do grid) para adensamento de pontos nos estados
grid_geral <- expand.grid( # Criar malha regular
  X=seq(min(x),max(x),dis), # Combinar cada x e y
  Y=seq(min(y),max(y),dis)) |>
  mutate( #teste ponto-no-pol√≠gono, TRUE se (X,Y) caem no pol√≠gono
    flag_ms = def_pol(X, Y, pol_ms),
    flag_mt = def_pol(X, Y, pol_mt),
    flag_go = def_pol(X, Y, pol_go),
    flag_df = def_pol(X, Y, pol_df)
  ) |>
  filter(flag_ms | flag_go | flag_mt | flag_df) |> # manter pontos correspondentes ao menos 1 dos limites
  select(-c(flag_ms,flag_mt,flag_go,flag_df)) # remover colunas criadas
plot(grid_geral)
sp::gridded(grid_geral) = ~ X + Y
```

#### Interpola√ß√£o por Krigagem Ordin√°ria - oco2-sif

Os par√¢metros do semivariograma (alcance, patamar e efeito pepita) da sif foram estabelecidos com base na amostragem total dos pontos da base de dados (sem a parte de "sample_n()").

  Estimar valores m√©dios de concentra√ß√£o de SIF entre 2015 e 2023
  
```{r, eval=FALSE}
df_aux <- oco2_sif |> 
  filter(year == my_year) |> 
  group_by(longitude, latitude) |> 
  summarise(
    SIF_757 = mean(SIF_757,na.rm=TRUE), # m√©dia sif
    .groups = "drop"
  ) |> sample_n(10000) # amostra
sp::coordinates(df_aux) = ~ longitude + latitude # Converter data frame para objeto espacial - atribuir as colunas longitude/latitude como coordenadas. V√°rias fun√ß√µes de geoestat√≠stica do pacote gstat (como variogram() e krige()) n√£o aceitam um data frame, mas sim um objeto com coordenadas. Agora, a vari√°vel sif passa a ser o atributo associado a cada ponto espacial.

form <- SIF_757 ~ 1 # "~ 1" modelo de m√©dia constante, mas desconhecida (somente intercepto - assume m√©dia global, sem covari√°veis).

vari_exp <- gstat::variogram(form, data = df_aux,
                      cressie = FALSE, # estimador cl√°ssico do semivar.
                      cutoff = 1.25, # dist√¢ncia semivar
                      width = 0.08) # distancia entre pontos

# vari_exp <- gstat::variogram(form, data = df_aux,
#                       cressie = FALSE, #estimador cl√°ssico do semivar.
#                       cutoff = 1, # dist√¢ncia semivar
#                       width = 0.08) # distancia entre pontos

vari_exp  |>
  ggplot(aes(x=dist, y=gamma)) +
  geom_point() +
  labs(x="lag (¬∫)",
       y=expression(paste(gamma,"(h)")))
```

```{r, eval=FALSE}
patamar=0.039
alcance=0.7
epepita=0.0352
modelo_1 <- fit.variogram(vari_exp,vgm(patamar,"Sph",alcance,epepita))
modelo_2 <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
modelo_3 <- fit.variogram(vari_exp,vgm(patamar,"Gau",alcance,epepita))
plot_my_models(modelo_1,modelo_2,modelo_3)
modelo <- modelo_2 ## sempre modificar
```

```{r, eval=FALSE}
tictoc::tic()
ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                     block=c(0.1,0.1),
                     nsim=0,
                     na.action=na.pass,
                     debug.level=-1
)
tictoc::toc()
```

```{r, eval=FALSE}
ko_variavel |> 
  as_tibble() |> 
    ggplot(aes(x=X, y=Y)) +
  geom_tile(aes(fill = var1.pred)) +
  scale_fill_viridis_c(option = "mako") +
  coord_equal() +
  labs(x="Longitude",
       y="Latitude",
       fill="SIF",
       title = my_year) +
  theme_bw()
```

```{r, eval=FALSE}
df_kgr <- ko_variavel |> 
      as_tibble() |> 
      select(-var1.var) |> 
      rename(longitude=X,latitude=Y,SIF_757=var1.pred)  |> 
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF"))) 
             )
resul <- vector()
estado <- df_kgr$state
for(i in 1:nrow(df_kgr)){
  if(estado[i]!="Other"){
    my_citys_obj <- municipality %>%
      filter(abbrev_state == estado[i])
    n_citys <- nrow(my_citys_obj)
    my_citys_names <- my_citys_obj %>% pull(name_muni)
    resul[i] <- "Other"
    for(j in 1:n_citys){
      pol_city <- my_citys_obj$geom  %>%
        purrr::pluck(j) %>%
        as.matrix()
      if(def_pol(df_kgr$longitude[i],
                 df_kgr$latitude[i],
                 pol_city)){
        resul[i] <- my_citys_names[j]
      }
    }
  }
}
df_kgr$city_ref <- resul
```


```{r, eval=FALSE}
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    oco2_sif |> 
      filter(year == my_year) |> 
      select(longitude,latitude,SIF_757,state,city_ref) |> 
      rbind(
        df_kgr
      ) |> 
      group_by(city_ref) |> 
      summarise(
        SIF_757 = mean(SIF_757,na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  mutate(
    SIF_757 = ifelse(is.na(SIF_757),median(SIF_757,na.rm = TRUE),SIF_757)) |>
  ggplot()  +
  geom_sf(aes(fill=SIF_757), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = df_kgr, 
  #            aes(longitude, latitude, #size = emission,
  #                color="red")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'SIF_757',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```

#### Estimativa de SIF para o Brasil Central

```{r, eval=FALSE}
oco2_sif_kgr <- map_df(2015:2023,~{
  set.seed(1235)
  df_aux <- oco2_sif |>
    group_by(longitude, latitude) |>
    filter(year == .x) |>
    summarise(
      SIF_757 = mean(SIF_757,na.rm=TRUE),
      .groups = "drop"
    ) |> sample_n(10000)
  sp::coordinates(df_aux) = ~ longitude + latitude
  form <- SIF_757 ~ 1
  vari_exp <- gstat::variogram(form, data = df_aux,
                               cressie = FALSE,
                               cutoff = 1.25, # dist√¢ncia m√°xima
                               width = 0.08) # distancia entre pontos
  vari_exp  |>
    ggplot(aes(x=dist, y=gamma)) +
    geom_point() +
    labs(x="lag (¬∫)",
         y=expression(paste(gamma,"(h)")))
  patamar=0.039
  alcance=0.7
  epepita=0.0352
  modelo <- fit.variogram(vari_exp,vgm(patamar,"Sph",alcance,epepita))
  ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                       block=c(0.1,0.1),
                       nsim=0,
                       na.action=na.pass,
                       debug.level=-1
  )
  df_kgr <- ko_variavel |>
      as_tibble() |>
      select(-var1.var) |>
      rename(longitude=X,latitude=Y,SIF_757=var1.pred)  |>
      mutate(city_ref = "Other",
             state = ifelse(def_pol(longitude, latitude, pol_ms),"MS",
                            ifelse(def_pol(longitude, latitude, pol_mt),"MT",
                            ifelse(def_pol(longitude, latitude, pol_go),"GO",
                            "DF")))
             )
  resul <- vector()
  estado <- df_kgr$state
  for(i in 1:nrow(df_kgr)){
    if(estado[i]!="Other"){
      my_citys_obj <- municipality %>%
        filter(abbrev_state == estado[i])
      n_citys <- nrow(my_citys_obj)
      my_citys_names <- my_citys_obj %>% pull(name_muni)
      resul[i] <- "Other"
      for(j in 1:n_citys){
        pol_city <- my_citys_obj$geom  %>%
          purrr::pluck(j) %>%
          as.matrix()
        if(def_pol(df_kgr$longitude[i],
                   df_kgr$latitude[i],
                   pol_city)){
          resul[i] <- my_citys_names[j]
        }
      }
    }
  }
  df_kgr$city_ref <- resul

  df_final <- df_kgr |>
        mutate(year = .x)
  return(df_final)
})
# write_rds(oco2_sif_kgr,"../data-raw/oco2-sif-kgr.rds")
```

```{r, eval=FALSE}
sif_kgr <- read_rds("../data-raw/oco2-sif-kgr.rds")
```

```{r, eval=FALSE}
oco2_sif_bind <- oco2_sif |> 
  select(longitude,latitude,SIF_757,city_ref,state,year) |> 
  rbind(oco2_sif_kgr)

map(2015:2023,~{
  municipality |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      oco2_sif_bind |> 
        filter(year == .x) |> 
        select(longitude,latitude,SIF_757,state,city_ref) |> 
        group_by(city_ref) |> 
        summarise(
          SIF_757 = mean(SIF_757,na.rm=TRUE),
          .groups = "drop"
        ) |> 
        rename(name_muni = city_ref),
      by = c("name_muni")
    ) |> 
    mutate(
      SIF_757 = ifelse(is.na(SIF_757),median(SIF_757,na.rm = TRUE),SIF_757)) |>
    ggplot()  +
    geom_sf(aes(fill=SIF_757), color="transparent",
            size=.05, show.legend = TRUE)  +
    # geom_point(data = df_kgr, 
    #            aes(longitude, latitude, #size = emission,
    #                color="red")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'SIF_757',
         x = 'Longitude',
         y = 'Latitude',
         title = .x) +
    scale_fill_viridis_c()})

# write_rds(oco2_sif_bind,"../data/oco2-sif-bind.rds")
```

### üçÉ Entrada com a Base: `appeears-modis.rds`
  
```{r, eval=FALSE} 
# original archive "appeears-modis.rds" = 8,7mb
# appeears data requisited by API (project fapesp)

appeears_modis <- read_rds("data/appeears_modis.rds") |> 
  rename(
    FPAR = media_fpar,
    LAI = media_lai,
    NDVI = media_ndvi,
    EVI = media_evi,
    ET = media_et
  )

glimpse(appeears_modis)
```

```{r, eval=FALSE}
appeears_modis |> 
  filter(year == 2020) |>
  ggplot(aes(x=lon,y=lat)) +
  geom_point()
```

#### Gerar mapas das vari√°veis - appeears
```{r, eval=FALSE}
# my_year = 2021

# Definir a vari√°vel
variavel <- "FPAR" # <-- mudar

# Definir os limites esperados para cada vari√°vel - padronizar visualiza√ß√£o
limits_map <- list(
  NDVI = c(-1, 1),
  EVI  = c(-1, 1),
  FPAR = c(0, 1),
  LAI  = c(0, 7), # m√°ximo valor = 6,85 (ap√≥s remo√ß√£o de outliers)
  ET   = NULL     # sem limite fixo
)

# Limite para a vari√°vel atual
limites <- limits_map[[variavel]]

# .data[[variavel]] # Para reconhecer o objeto "variavel" como nome de coluna, e n√£o como string

# Definir os anos
anos <- if (variavel == "ET") 2021:2023 else 2015:2023

# Aplicando fun√ß√£o para gera√ß√£o dos mapas de cada ano
for (my_year in anos) {

  # Gerando mapas
p <- municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    appeears_modis |> 
      group_by(year, city_ref) |> 
      reframe( #retornar somente coluna da variavel
        !!variavel := .data[[variavel]],na.rm=TRUE, # VERIFICAR - municipios em cinza ao cacular a media
        .groups = "drop"
      ) |>  
      filter(.data[[variavel]] <= 200) |> # Filtrar outliers absurdos
      rename(name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  filter(year == my_year) |> 
  ggplot()  +
  geom_sf(aes(fill=.data[[variavel]]), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = appeears_modis |> 
  #              filter(year==my_year), 
  #              aes(lon, lat, #size = emission,
  #                  color="red"))+
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = variavel,
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c(limits = limites)
  
  print(p)
  
    ggsave(filename = paste0("img/mapa_", variavel, "_", my_year, ".png"),
         plot = p)
} 
```

N√£o foi feita a interpola√ß√£o para dados do appeears, pois todos os munic√≠pios est√£o presentes, os dados agrupados por m√©dia.


#### üí® Entrada com a Base: `nasa-power.rds`
```{r, eval=FALSE} 
# original archive "nasa-power.rds" = 174,6mb

nasa_power <- read_rds("../data/nasa_power.rds") |> 
  rename(
    Radiacao = allsky_sfc_sw_dwn,
    Temperatura = t2m,
    Precipitacao = prectotcorr,
    Umidade = rh2m,
    Vento = ws2m,
    Pressao = ps
  )

glimpse(nasa_power)

# Temperatura (t2m), precipita√ß√£o (prectotcorr), radia√ß√£o solar (allsky) e umidade relativa a 2 m (rh2m), velocidade do vento a 2 metros (ws2m) e press√£o na superf√≠cie (ps).
```

```{r, eval=FALSE}
nasa_power |> 
  filter(year == 2023) |> 
  ggplot(aes(x=lon,y=lat)) +
  geom_point()
```

#### Classificando cada ponto em munic√≠pio 

J√° feito no script de faxina "nasa-power.Rmd"

#### Gerar mapa
```{r, eval=FALSE}
my_year <- 2022

# Atribuir ao objeto "variavel" a vari√°vel clim√°tica da base do nasa power que iremos trabalhar
  # Radiacao 
  # Temperatura
  # Precipitacao
  # Umidade 
  # Vento
  # Pressao

# Definir vari√°vel
variavel <- "Pressao" #mudar

# Estabelecer anos
anos <- 2015:2023

# Aplicando fun√ß√£o para gera√ß√£o dos mapas de cada ano
for (my_year in anos) {

n <- municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    nasa_power |> 
      group_by(year, city_ref) |>
      summarise(
        !!variavel := mean(.data[[variavel]],na.rm=TRUE), #Criar coluna com mesmo nome da variavel
        .groups = "drop"
      ) |> 
      rename(name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  filter(year == my_year) |> 
  ggplot()  +
  geom_sf(aes(fill=.data[[variavel]]), color="transparent",
          size=.05, show.legend = TRUE)  +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = variavel,
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()

  print(n)
  
  # ggsave(filename = paste0("img/mapa_nasapower", variavel, "_", my_year, ".png"),
  #        plot = n)
}
```



#### Criando o grid (malha de pontos) para valores n√£o amostrados - nasa-power
```{r, eval=FALSE}
# vetores para coordenadas x e y selecionadas da base do IBGE1
# Extrair coordenadas da base nasa_power para definir extens√£o do grid
x<-nasa_power$lon
y<-nasa_power$lat
dis <- 0.5 # dist√¢ncia (do grid) para adensamento de pontos nos estados
grid_geral <- expand.grid( # Criar malha regular
  X=seq(min(x),max(x),dis), # Combinar cada x e y
  Y=seq(min(y),max(y),dis)) |>
  mutate( #teste ponto-no-pol√≠gono, TRUE se (X,Y) caem no pol√≠gono
    flag_ms = def_pol(X, Y, pol_ms),
    flag_mt = def_pol(X, Y, pol_mt),
    flag_go = def_pol(X, Y, pol_go),
    flag_df = def_pol(X, Y, pol_df)
  ) |>
  filter(flag_ms | flag_go | flag_mt | flag_df) |> # manter pontos correspondentes ao menos 1 dos limites
  select(-c(flag_ms,flag_mt,flag_go,flag_df)) # remover colunas criadas
plot(grid_geral)
sp::gridded(grid_geral) = ~ X + Y
```
#### Interpola√ß√£o por Krigagem Ordin√°ria - nasa-power

Par√¢metros testados para contruir o semivariograma, com base na vari√°vel:
  
*Temperatura*
  cutoff = 5,  
  width = 0.09
  patamar=2.2
  alcance=4.5
  epepita=0.2
  
*Radiacao*
**Modelo Gaussiano teve menro R2, mas melhor interpola√ß√£o**
  cutoff = 12.5
  width = 0.5
  patamar = 1.4
  alcance = 11.25
  epepita = 0.1
  
*Precipitacao*
  cutoff = 6,  
  width = 0.5
  patamar= 1.35
  alcance= 15
  epepita= 0.01
  
*Umidade*
**Muitos avisos de warning**
  ***Warning in fit.variogram(vari_exp, vgm(patamar, "Sph", alcance, epepita)) :No convergence after 200 iterations: try different initial values?***
  cutoff = 12,  
  width = 0.5
  patamar= 60
  alcance= 11
  epepita= 0.1
  
*Vento*
**3 warning**
  cutoff = 5,  
  width = 0.08
  patamar=.2
  alcance=1.5
  epepita=0
  
*Pressao* 
  cutoff = 7, 
  width = 0.35
  patamar=4.2
  alcance=5
  epepita=.4

```{r, eval=FALSE}
df_aux <- nasa_power |> 
  filter(year %in% my_year) |> 
  group_by(lon, lat) |> 
  summarise(
    !!variavel := mean(.data[[variavel]],na.rm=TRUE), # m√©dia temperatura
    .groups = "drop"
  ) # |> sample_n(546) # tamanho m√°ximo dos dados
sp::coordinates(df_aux) = ~ lon + lat # Converter data frame para objeto espacial - atribuir as colunas longitude/latitude como coordenadas. V√°rias fun√ß√µes de geoestat√≠stica do pacote gstat (como variogram() e krige()) n√£o aceitam um data frame, mas sim um objeto com coordenadas. Agora, a vari√°vel passa a ser o atributo associado a cada ponto espacial.

# Converter string em f√≥rmula para atribuir a variavel preestabelecida
form <- as.formula(paste(variavel, "~ 1")) 

vari_exp <- gstat::variogram(form, data = df_aux,
                      cressie = FALSE, #estimador cl√°ssico do semivar.
                      cutoff = 7, # dist√¢ncia  
                      width = 0.35) # distancia entre pontos
vari_exp  |>
  ggplot(aes(x=dist, y=gamma)) +
  geom_point() +
  labs(x="lag (¬∫)",
       y=expression(paste(gamma,"(h)")))
```

```{r, eval=FALSE}
patamar=4.2
alcance=5
epepita=.4
modelo_1 <- fit.variogram(vari_exp,vgm(patamar,"Sph",alcance,epepita))
modelo_2 <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))
modelo_3 <- fit.variogram(vari_exp,vgm(patamar,"Gau",alcance,epepita))
plot_my_models(modelo_1,modelo_2,modelo_3)
modelo <- modelo_1 ## sempre modificar
```

```{r, eval=FALSE}
ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                     block=c(0.1,0.1),
                     nsim=0,
                     na.action=na.pass,
                     debug.level=-1
)
```

```{r, eval=FALSE}
ko_variavel |> 
  as_tibble() |> 
    ggplot(aes(x=X, y=Y)) +
  geom_tile(aes(fill = var1.pred)) +
  scale_fill_viridis_c(option = "mako") +
  coord_equal() +
  labs(x="Longitude",
       y="Latitude",
       fill=variavel,
       title = my_year) +
  theme_bw()
```

```{r, eval=FALSE}
df_kgr <- ko_variavel |> 
      as_tibble() |> 
      select(-var1.var) |> 
      rename(lon=X,lat=Y,!!variavel :=var1.pred)  |> 
      mutate(city_ref = "Other",
             state = ifelse(def_pol(lon, lat, pol_ms),"MS",
                            ifelse(def_pol(lon, lat, pol_mt),"MT",
                            ifelse(def_pol(lon, lat, pol_go),"GO",
                            "DF"))) 
             )
resul <- vector()
estado <- df_kgr$state
for(i in 1:nrow(df_kgr)){
  if(estado[i]!="Other"){
    my_citys_obj <- municipality %>%
      filter(abbrev_state == estado[i])
    n_citys <- nrow(my_citys_obj)
    my_citys_names <- my_citys_obj %>% pull(name_muni)
    resul[i] <- "Other"
    for(j in 1:n_citys){
      pol_city <- my_citys_obj$geom  %>%
        purrr::pluck(j) %>%
        as.matrix()
      if(def_pol(df_kgr$lon[i],
                 df_kgr$lat[i],
                 pol_city)){
        resul[i] <- my_citys_names[j]
      }
    }
  }
}
df_kgr$city_ref <- resul
```


```{r, eval=FALSE}
municipality |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    nasa_power |> 
      filter(year == my_year) |> 
      select(lon,lat,variavel,state,city_ref) |> 
      rbind(
        df_kgr
      ) |> 
      group_by(city_ref) |> 
      summarise(
        !!variavel := mean(.data[[variavel]],na.rm=TRUE),
        .groups = "drop"
      ) |> 
      rename(  name_muni = city_ref),
    by = c("name_muni")
  ) |> 
  mutate(
    !!variavel := ifelse(is.na(.data[[variavel]]),median(.data[[variavel]],na.rm = TRUE),.data[[variavel]])) |>
  ggplot()  +
  geom_sf(aes(fill=.data[[variavel]]), color="transparent",
          size=.05, show.legend = TRUE)  +
  # geom_point(data = df_kgr, 
  #            aes(lon, lat, #size = emission,
  #                color="red")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = variavel,
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c()
```

#### Estimativa da vari√°vel para o Brasil Central - nasa-power

```{r, eval=FALSE}
nome_variavel <- paste0("nasa_power_",variavel,"_kgr")

nome_variavel <- map_df(2015:2023,~{
  set.seed(1235)
  df_aux <- nasa_power |>
    group_by(lon, lat) |>
    filter(year == .x) |>
    summarise(
      !!variavel := mean(.data[[variavel]],na.rm=TRUE),
      .groups = "drop"
    ) 
  sp::coordinates(df_aux) = ~ lon + lat
  form <- as.formula(paste(variavel, "~ 1")) 
  vari_exp <- gstat::variogram(form, data = df_aux,
                               cressie = FALSE,
                               cutoff = 7, # !! mudar
                               width = 0.35) # !! mudar
  vari_exp  |>
    ggplot(aes(x=dist, y=gamma)) +
    geom_point() +
    labs(x="lag (¬∫)",
         y=expression(paste(gamma,"(h)")))
    patamar=4.2 #!! mudar
    alcance=5 #!! mudar
    epepita=.4 #!! mudar
  modelo <- fit.variogram(vari_exp,vgm(patamar,"Exp",alcance,epepita))  # !! mudar
  ko_variavel <- krige(formula=form, df_aux, grid_geral, model=modelo,
                       block=c(0.1,0.1),
                       nsim=0,
                       na.action=na.pass,
                       debug.level=-1
  )
  df_kgr <- ko_variavel |>
      as_tibble() |>
      select(-var1.var) |>
      rename(lon=X,lat=Y,!!variavel :=var1.pred)  |>
      mutate(city_ref = "Other",
             state = ifelse(def_pol(lon, lat, pol_ms),"MS",
                            ifelse(def_pol(lon, lat, pol_mt),"MT",
                            ifelse(def_pol(lon, lat, pol_go),"GO",
                            "DF")))
             )
  resul <- vector()
  estado <- df_kgr$state
  for(i in 1:nrow(df_kgr)){
    if(estado[i]!="Other"){
      my_citys_obj <- municipality %>%
        filter(abbrev_state == estado[i])
      n_citys <- nrow(my_citys_obj)
      my_citys_names <- my_citys_obj %>% pull(name_muni)
      resul[i] <- "Other"
      for(j in 1:n_citys){
        pol_city <- my_citys_obj$geom  %>%
          purrr::pluck(j) %>%
          as.matrix()
        if(def_pol(df_kgr$lon[i],
                   df_kgr$lat[i],
                   pol_city)){
          resul[i] <- my_citys_names[j]
        }
      }
    }
  }
  df_kgr$city_ref <- resul

  df_final <- df_kgr |>
        mutate(year = .x)
  return(df_final)
})
write_rds(nome_variavel,paste0("../data-raw/nasa-power-",variavel,"-kgr.rds"))
```

```{r, eval=FALSE}
# Rodar somente quando necess√°rio!!!!
nasa_power_kgr <- read_rds(paste0("../data-raw/nasa-power-",variavel,"-kgr.rds"))
```

```{r, eval=FALSE}
nasa_power_bind <- nasa_power |> 
  select(lon,lat,.data[[variavel]],city_ref,state,year) |> 
  rbind(nasa_power_kgr)

map(2015:2023,~{
  municipality |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      nasa_power_bind |> 
        filter(year == .x) |> 
        select(lon,lat,.data[[variavel]],state,city_ref) |> 
        group_by(city_ref) |> 
        summarise(
          !!variavel := mean(.data[[variavel]],na.rm=TRUE),
          .groups = "drop"
        ) |> 
        rename(name_muni = city_ref),
      by = c("name_muni")
    ) |> 
    mutate(
      !!variavel := ifelse(is.na(.data[[variavel]]),median(.data[[variavel]],na.rm = TRUE),.data[[variavel]])) |>
    ggplot()  +
    geom_sf(aes(fill=.data[[variavel]]), color="transparent",
            size=.05, show.legend = TRUE)  +
    # geom_point(data = df_kgr, 
    #            aes(longitude, latitude, #size = emission,
    #                color="red")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = variavel,
         x = 'Longitude',
         y = 'Latitude',
         title = .x) +
    scale_fill_viridis_c()})

write_rds(nasa_power_bind,paste0("../data/nasa-power-",variavel,"-bind.rds"))
```

-->

### ü™ì Entrada com a Base: `prodes-deforestation.rds`
```{r, eval=FALSE} 
# original archive "prodes-deforestation.rds" = 2.2gb

prodes_deforestation <- read_rds("data/prodes-deforestation.rds")
  # sample_n(1000000)
  # "state" column previously filtred 

glimpse(prodes_deforestation)
```

```{r, eval=FALSE}
prodes_deforestation |> 
  sample_n(100000) |> 
  filter(categorie == 15) |> 
  ggplot(aes(x=x,y=y)) +
  geom_point()
```
#### Gerar mapa
```{r, eval=FALSE}
# Alocando intensidade com base nas observa√ß√µes de desmatamento no ano
df_prodes <- prodes_deforestation |> 
  group_by(categorie, state, muni) |> 
  count() |> 
  group_by(categorie) |> 
  mutate(
    percent = n/sum(n)*100
  )
```

```{r, eval=FALSE}
# Gerando o mapa de intensidade de desmatamento
 municipality |> 
    filter(abbrev_state %in% my_states) |> 
    left_join(
      df_prodes |> 
        filter(categorie == 22) |>  # mudar anos
        rename(name_muni = muni),
      by = c("name_muni")
    ) |> 
  ggplot() +
   geom_sf(aes(fill=percent), color="transparent",
            size=.05, show.legend = TRUE)  +
    # geom_point(data = df_kgr, 
    #            aes(longitude, latitude, #size = emission,
    #                color="red")) +
    theme_bw() +
    theme(
      axis.text.x = element_text(size = rel(.9), color = "black"),
      axis.title.x = element_text(size = rel(1.1), color = "black"),
      axis.text.y = element_text(size = rel(.9), color = "black"),
      axis.title.y = element_text(size = rel(1.1), color = "black"),
      legend.text = element_text(size = rel(1), color = "black"),
      legend.title = element_text(face = 'bold', size = rel(1.2))
    ) +
    labs(fill = 'Intensidade',
         x = 'Longitude',
         y = 'Latitude',
         title = 'Desmatamento') +
    scale_fill_viridis_c()

# Munic√≠pio em destaque no mapa √© Corumb√° (para anos como 2022)
 # municipality |> 
 #    filter(abbrev_state %in% my_states) |> 
 #   filter(
 #     name_muni == "Corumb√°"
 #   ) |> 
 #    left_join(
 #      df_prodes |> 
 #        filter(categorie == 16) |> 
 #        rename(name_muni = muni),
 #      by = c("name_muni")
 #    ) 
```
-->

### üî• Entrada com a Base: `deter_queimadas.rds`

√â importante ressaltar que, embora diversos estados estejam contemplados nas observa√ß√µes, estes n√£o apresentam informa√ß√µes referentes a queimadas, somente desmatamento ou outras.

Apenas o estado do Mato Grosso apresenta observa√ß√µes de queimadas

Disponibilidade de dados de cicatriz de queimada para biomas como Amaz√¥nia e Pantanal (https://terrabrasilis.dpi.inpe.br/downloads)

```{r, eval=FALSE} 
# original archive "deter-queimadas.rds" = 122,1mb

deter_queimadas <- read_rds("data/deter_queimadas.rds")

# glimpse(deter_queimadas)

# deter_queimadas |> 
#   filter(UF == "MT",
#          ANO == 2024,
#          CLASSNAME == "CICATRIZ_DE_QUEIMADA") |> 
#   glimpse()
```

```{r, eval=FALSE}
deter_queimadas |> 
  # pull(ANO) |> unique()
  filter(ANO == 2020) |> 
  ggplot(aes(x=longitude,y=latitude)) +
  geom_point()
```

### Padronizando nomes dos munic√≠pios da base DETER com os do pacote geobr

Este chunk tem como objetivo padronizar para posterior incorpora√ß√£o, necess√°ria para evitar perda de informa√ß√£o durante a gera√ß√£o dos mapas

```{r, eval=FALSE}
library(stringi)  # para normaliza√ß√£o de strings

# Alocando √°rea de queimadas
df_deter <- deter_queimadas |> 
  filter(UF %in% my_states) |> 
  rename(name_muni = MUNICIPALI) |> 
  select(name_muni, ANO, AREAMUNKM,) |> 
  arrange(name_muni) |> 
  group_by(ANO, name_muni) |> 
  summarise(
    area_queimada_muni_km = sum(AREAMUNKM, na.rm = TRUE),
    .groups = "drop"
  ) |> 
  mutate(
    name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
    name_muni = trimws(name_muni)
  )

# glimpse(df_deter)

# Pacote geobr 
munic_geobr <- municipality |> 
  filter(abbrev_state %in% my_states) |> 
  select(name_muni, abbrev_state) |> 
  arrange(name_muni) |>  
  mutate(
    name_muni = stri_trans_general(tolower(name_muni), "Latin-ASCII"),
    #stri_trans_general(..., "Latin-ASCII") ‚Üí remove acentos e normaliza para compara√ß√£o;
    #tolower() ‚Üí padroniza para min√∫sculas;
    #trimws() ‚Üí remove espa√ßos extras.
    name_muni = trimws(name_muni)
  )

glimpse(munic_geobr)
```



#### Gerar mapa  - deter
```{r, eval=FALSE}
my_year = 2022 # mudar anos (detalhe: alguns anos, como 2016, s√≥ tem para 1 estado)

# Fazer filtro por ano antes do join para passar NA = 0 nos munic√≠pios faltantes
df_deter_ano <- df_deter |> 
  filter(ANO == my_year)

munic_geobr |> 
  filter(abbrev_state %in% my_states) |> 
  left_join(
    df_deter_ano |> 
      group_by(ANO, name_muni) |> 
      summarise(area_queimada_muni_km = sum(area_queimada_muni_km, na.rm = TRUE)),
    by = "name_muni"
  ) |> 
  mutate(area_queimada_muni_km = replace_na(area_queimada_muni_km, 0)) |>
  ggplot() +
  geom_sf(aes(fill=area_queimada_muni_km), color="transparent",
          size=.05, show.legend = TRUE) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = rel(.9), color = "black"),
    axis.title.x = element_text(size = rel(1.1), color = "black"),
    axis.text.y = element_text(size = rel(.9), color = "black"),
    axis.title.y = element_text(size = rel(1.1), color = "black"),
    legend.text = element_text(size = rel(1), color = "black"),
    legend.title = element_text(face = 'bold', size = rel(1.2))
  ) +
  labs(fill = 'Queimadas (√°rea km)',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_viridis_c(
    option = "inferno"
  )
```





